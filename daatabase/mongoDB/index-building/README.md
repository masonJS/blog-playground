# MongoDB 인덱스 빌드(Index Build)


---

## 목차

1. [개요: 채워진 컬렉션에 인덱스 빌드하기](#1-개요-채워진-컬렉션에-인덱스-빌드하기)
2. [인덱스 빌드의 역사: Foreground vs Background vs 현재 방식](#2-인덱스-빌드의-역사-foreground-vs-background-vs-현재-방식)
3. [인덱스 빌드 중 잠금(Lock) 동작 방식](#3-인덱스-빌드-중-잠금lock-동작-방식)
4. [핵심 내부 구조: 세 가지 임시 데이터 구조](#4-핵심-내부-구조-세-가지-임시-데이터-구조)
5. [인덱스 빌드 전체 프로세스 상세 분석](#5-인덱스-빌드-전체-프로세스-상세-분석)
6. [복제본 세트(Replica Set)에서의 인덱스 빌드](#6-복제본-세트replica-set에서의-인덱스-빌드)
7. [커밋 쿼럼(Commit Quorum) vs 쓰기 고려(Write Concern)](#7-커밋-쿼럼commit-quorum-vs-쓰기-고려write-concern)
8. [제약 조건 위반과 인덱스 빌드 실패](#8-제약-조건-위반과-인덱스-빌드-실패)
9. [샤딩 환경에서의 인덱스 빌드](#9-샤딩-환경에서의-인덱스-빌드)
10. [인덱스 빌드가 성능에 미치는 영향](#10-인덱스-빌드가-성능에-미치는-영향)
11. [빌드 실패와 복구 메커니즘](#11-빌드-실패와-복구-메커니즘)
12. [인덱스 빌드 모니터링과 종료](#12-인덱스-빌드-모니터링과-종료)
13. [MongoDB 7.1 이후 개선 사항](#13-mongodb-71-이후-개선-사항)
14. [실무 적용 가이드](#14-실무-적용-가이드)
15. [핵심 요약](#15-핵심-요약)

---

## 1. 개요: 채워진 컬렉션에 인덱스 빌드하기

### 인덱스 빌드란?

이미 데이터가 존재하는 컬렉션(Populated Collection)에 새로운 인덱스를 생성하는 작업을 **인덱스 빌드**라고 한다. 빈 컬렉션에 인덱스를 생성하는 것과 달리, 채워진 컬렉션에서는 기존의 모든 문서를 스캔하여 인덱스 데이터 구조를 구축해야 하므로 복잡한 프로세스가 필요하다.

### 왜 복잡한가?

1. **대량의 데이터 처리**: 수백만, 수천만 건의 문서를 모두 읽고 인덱스 키를 생성해야 한다.
2. **서비스 연속성**: 인덱스 빌드 중에도 애플리케이션은 데이터를 읽고 쓸 수 있어야 한다.
3. **데이터 일관성**: 빌드 중에 발생하는 쓰기 작업도 인덱스에 반영되어야 한다.
4. **분산 환경**: 복제본 세트나 샤딩 환경에서는 모든 노드가 동일한 인덱스를 가져야 한다.

---

## 2. 인덱스 빌드의 역사: Foreground vs Background vs 현재 방식

### 과거의 방식들

MongoDB는 버전이 올라가면서 인덱스 빌드 방식을 크게 개선해왔다.

#### Foreground 인덱스 빌드 (레거시)

```
특징:
- 빌드 속도가 빠름
- 효율적인 인덱스 데이터 구조 생성
- 단점: 빌드 기간 동안 해당 데이터베이스 전체에 대한 읽기/쓰기 차단
```

Foreground 빌드는 마치 "도서관 전체를 폐쇄하고 책을 정리하는 것"과 같았다. 빠르지만, 그 동안 아무도 도서관을 이용할 수 없었다.

#### Background 인덱스 빌드 (레거시)

```
특징:
- 빌드 중 읽기/쓰기 가능
- 빌드 속도가 느림
- 결과적으로 덜 효율적인 인덱스 구조
```

Background 빌드는 "도서관을 운영하면서 책을 정리하는 것"과 같았다. 사용자는 이용할 수 있지만, 정리가 느리고 결과도 덜 깔끔했다.

### 현재의 최적화된 방식 (MongoDB 4.2+)

현재 MongoDB는 두 방식의 장점만을 취한 **최적화된 인덱스 빌드**를 사용한다.

```
현재 방식의 특징:
- Foreground 수준의 효율적인 인덱스 구조 생성
- Background 수준의 읽기/쓰기 허용
- 빌드 시작과 끝에만 짧은 독점 잠금
- 중간 과정에서는 양보(yield)를 통해 다른 작업과 교차 진행
```

**중요**: 현재 MongoDB는 `createIndexes` 명령에서 `background` 옵션을 **무시**한다. 항상 최적화된 방식으로 빌드한다.

---

## 3. 인덱스 빌드 중 잠금(Lock) 동작 방식

### 잠금의 종류

MongoDB의 인덱스 빌드에서 사용되는 주요 잠금 종류:

| 잠금 유형 | 기호 | 설명 | 다른 작업 허용 |
|----------|------|------|---------------|
| 독점 잠금 (Exclusive) | X | 모든 접근 차단 | 읽기 ❌, 쓰기 ❌ |
| 공유 잠금 (Shared) | S | 쓰기만 차단 | 읽기 ✅, 쓰기 ❌ |
| 의도 독점 (Intent Exclusive) | IX | 양보 가능한 상태 | 읽기 ✅, 쓰기 ✅ |

### 인덱스 빌드 단계별 잠금 변화

```
[1] 시작 단계
    └─ X Lock (독점 잠금)
    └─ 메타데이터 초기화, 임시 테이블 생성
    └─ 매우 짧은 시간
    
[2] 컬렉션 스캔 단계
    └─ IX Lock (의도 독점)
    └─ 주기적으로 양보하여 다른 작업 허용
    └─ 가장 오래 걸리는 단계
    
[3] 사이드 쓰기 처리 단계
    └─ IX Lock → S Lock
    └─ 읽기는 허용, 쓰기는 차단
    
[4] 완료 단계
    └─ X Lock (독점 잠금)
    └─ 인덱스를 "사용 가능"으로 표시
    └─ 매우 짧은 시간
```

### 실제 서비스에 미치는 영향

핵심은 **독점 잠금(X Lock)이 시작과 끝에만 짧게 걸린다**는 것이다. 대부분의 시간은 IX Lock 상태로, 읽기와 쓰기가 모두 가능하다.

```
시간 흐름 예시 (100만 건 컬렉션):

|--X--|------------ IX (양보하며 진행) ------------|--S--|--X--|
 0.1초                    약 5분                    0.5초  0.1초

총 5분 40초 중 실제 차단 시간: 약 0.2초
```

---

## 4. 핵심 내부 구조: 세 가지 임시 데이터 구조

인덱스 빌드가 시작되면 MongoDB는 세 가지 중요한 데이터 구조를 생성한다. 이것들을 이해하면 전체 프로세스가 명확해진다.

### 4.1 인덱스 메타데이터 항목

```
역할: 인덱스의 기본 정보 저장
내용: 인덱스 이름, 대상 필드, 옵션 등
상태: "building" → "ready"
```

인덱스가 빌드 중인지, 완료되었는지를 나타내는 메타데이터다.

### 4.2 사이드 쓰기 테이블 (Side Writes Table)

```
역할: 빌드 중 발생하는 쓰기 작업의 키를 임시 저장
문제 상황: 컬렉션 스캔 중에 새 문서가 추가되면?
해결책: 사이드 쓰기 테이블에 기록해두고 나중에 처리
```

**비유로 이해하기:**

```
시나리오: 도서관에서 A~Z 순서로 책을 정리하는 중

도서관 사서: "지금 M까지 정리했어요"
이용자: "새 책 'Python 입문'을 기증할게요!"
도서관 사서: "좋아요, 일단 '나중에 정리할 책' 상자에 넣어둘게요"
           (→ 사이드 쓰기 테이블)

... 정리 계속 ...

도서관 사서: "Z까지 다 정리했어요. 이제 '나중에 정리할 책' 상자를 비울게요"
           "Python 입문은 P 자리에..."
```

**처리 방식:**

1. 컬렉션 스캔 중 새 쓰기 발생 → 사이드 쓰기 테이블에 키 저장
2. 스캔 완료 후 사이드 쓰기 테이블을 **선입선출(FIFO)** 방식으로 처리
3. 처리 중에도 새 쓰기가 발생하면 계속 테이블에 추가
4. 최종적으로 테이블이 빌 때까지 반복

### 4.3 제약 조건 위반 테이블 (Constraint Violation Table)

```
역할: 키 생성 오류가 발생할 수 있는 문서 임시 저장
예시: unique 인덱스 빌드 중 중복 값 발견
처리: 빌드 완료 시점에 다시 검사
```

**왜 즉시 에러를 내지 않는가?**

```
시나리오: email 필드에 unique 인덱스 생성

스캔 중 발견:
  - doc1: email = "kim@test.com"
  - doc2: email = "kim@test.com"  ← 중복!

하지만...
  - 빌드 완료 전에 doc2가 삭제될 수도 있음
  - 빌드 완료 전에 doc2의 email이 수정될 수도 있음

따라서:
  - 일단 제약 조건 위반 테이블에 기록
  - 빌드 완료 시점에 다시 검사
  - 그때도 중복이면 → 에러 발생, 빌드 실패
  - 중복이 해소되었으면 → 정상 완료
```

---

## 5. 인덱스 빌드 전체 프로세스 상세 분석

전체 프로세스를 12단계로 나누어 상세히 분석한다.

### 단계 1: 초기 잠금 획득

```
동작: 컬렉션에 독점 잠금(X Lock) 획득
목적: 메타데이터 변경을 안전하게 수행
영향: 모든 읽기/쓰기 차단
지속: 매우 짧음 (밀리초 단위)
```

### 단계 2: 초기화

```
동작:
  1. 인덱스 메타데이터 항목 생성 (상태: building)
  2. 사이드 쓰기 테이블 생성
  3. 제약 조건 위반 테이블 생성

이 시점의 인덱스 상태: 존재하지만 아직 사용 불가
```

### 단계 3: 잠금 다운그레이드

```
동작: X Lock → IX Lock으로 다운그레이드
의미: 이제부터 다른 읽기/쓰기 작업 허용
특징: 주기적으로 양보(yield)하여 다른 작업에 CPU 시간 제공
```

### 단계 4: 컬렉션 스캔

```
동작:
  1. 컬렉션의 모든 문서를 순회
  2. 각 문서에서 인덱스 키 생성
  3. 키를 외부 소터(external sorter)에 저장
  4. 키 생성 오류 발생 시 → 제약 조건 위반 테이블에 저장
  5. 다른 오류 발생 시 → 빌드 즉시 실패

외부 소터(External Sorter):
  - 메모리 + 디스크를 사용하는 정렬 메커니즘
  - 메모리 한도 초과 시 디스크의 임시 파일 사용
  - 정렬 완료 후 인덱스에 순차적으로 덤프
```

### 단계 5: 사이드 쓰기 테이블 처리

```
동작:
  1. 사이드 쓰기 테이블을 FIFO 순서로 처리
  2. 키 생성 오류 → 제약 조건 위반 테이블로 이동
  3. 다른 오류 → 빌드 실패

주의:
  - 처리 중에도 새 쓰기가 발생하면 테이블에 추가됨
  - 스냅샷 시스템으로 처리할 키 수에 제한 설정
```

### 단계 6: 투표 및 쿼럼 대기 (복제본 세트만 해당)

```
조건: mongod가 복제본 세트의 멤버인 경우

Primary인 경우:
  1. 커밋 쿼럼(기본: 모든 투표 멤버)까지 대기
  2. 대기 중에도 사이드 쓰기 테이블 계속 처리

Secondary인 경우:
  1. "나 준비됐어" 투표를 Primary에게 전송
  2. Primary의 commitIndexBuild 또는 abortIndexBuild oplog 항목 대기
```

### 단계 7: 잠금 업그레이드 (S Lock)

```
동작: IX Lock → S Lock (공유 잠금)
영향: 쓰기 차단, 읽기 허용
목적: 사이드 쓰기 테이블 최종 처리를 위한 안정적 상태 확보
```

### 단계 8: 사이드 쓰기 테이블 최종 처리

```
동작: 남은 모든 레코드 처리
특징: 
  - 이 단계에서 복제가 일시 중지될 수 있음
  - 키 생성 오류 → 제약 조건 위반 테이블
  - 다른 오류 → 빌드 실패
```

### 단계 9: 최종 잠금 (X Lock)

```
동작: S Lock → X Lock
영향: 모든 읽기/쓰기 차단
지속: 매우 짧음
목적: 최종 검증과 인덱스 활성화를 위한 독점 접근
```

### 단계 10: 사이드 쓰기 테이블 제거

```
동작:
  1. 남은 작업 적용
  2. 테이블 제거

결과: 이 시점에서 인덱스는 모든 데이터를 포함
```

### 단계 11: 제약 조건 위반 테이블 처리

```
Primary인 경우:
  1. FIFO 순서로 테이블 처리
  2. 위반 없음 또는 해소됨:
     - 테이블 제거
     - commitIndexBuild oplog 항목 생성
  3. 위반 여전히 존재:
     - 빌드 중단
     - abortIndexBuild oplog 항목 생성
     - 에러 반환

Secondary인 경우:
  - 테이블을 단순히 제거
  - Primary가 이미 검증했으므로 위반 없다고 신뢰
```

### 단계 12: 완료

```
동작:
  1. 인덱스 메타데이터를 "ready"로 업데이트
  2. X Lock 해제

결과: 인덱스 사용 가능!
```

### 전체 프로세스 시각화

```
┌─────────────────────────────────────────────────────────────────────┐
│                     인덱스 빌드 전체 프로세스                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌──────────┐                                                       │
│  │ X Lock   │ ← 독점 잠금 (짧음)                                     │
│  │ 초기화    │                                                       │
│  └────┬─────┘                                                       │
│       ▼                                                             │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │ IX Lock - 컬렉션 스캔                                      │       │
│  │                                                          │       │
│  │  ┌─────────────────────────────────────────────────────┐ │       │
│  │  │ 문서1 → 키 생성 → 소터에 저장                         │ │       │
│  │  │ 문서2 → 키 생성 → 소터에 저장                         │ │       │
│  │  │ ...                                                  │ │       │
│  │  │ 문서N → 키 생성 → 소터에 저장                         │ │       │
│  │  └─────────────────────────────────────────────────────┘ │       │
│  │                                                          │       │
│  │  [동시에] 새 쓰기 발생 → 사이드 쓰기 테이블에 저장           │       │
│  │                                                          │       │
│  │  소터의 정렬된 키 → 인덱스로 덤프                          │       │
│  └──────────────────────────────────────────────────────────┘       │
│       ▼                                                             │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │ IX Lock - 사이드 쓰기 테이블 처리                          │       │
│  │                                                          │       │
│  │  FIFO 순서로 키 처리                                      │       │
│  │  새 쓰기 계속 발생 → 테이블에 추가                         │       │
│  └──────────────────────────────────────────────────────────┘       │
│       ▼                                                             │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │ [복제본 세트] 투표 및 쿼럼 대기                             │       │
│  │                                                          │       │
│  │  Secondary → "준비됨" 투표                                │       │
│  │  Primary → 쿼럼 확인                                      │       │
│  └──────────────────────────────────────────────────────────┘       │
│       ▼                                                             │
│  ┌──────────┐                                                       │
│  │ S Lock   │ ← 공유 잠금 (쓰기 차단)                               │
│  │ 최종처리  │                                                       │
│  └────┬─────┘                                                       │
│       ▼                                                             │
│  ┌──────────┐                                                       │
│  │ X Lock   │ ← 독점 잠금 (짧음)                                     │
│  │ 검증/완료 │                                                       │
│  └────┬─────┘                                                       │
│       ▼                                                             │
│  ┌──────────┐                                                       │
│  │ 인덱스    │                                                       │
│  │ 사용가능! │                                                       │
│  └──────────┘                                                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 6. 복제본 세트(Replica Set)에서의 인덱스 빌드

### 동시 인덱스 빌드 (Simultaneous Index Build)

복제본 세트에서는 모든 데이터 보유 멤버가 **동시에** 인덱스를 빌드한다.

```
요구사항: featureCompatibilityVersion 4.4 이상

프로세스:
1. Primary가 createIndexes 명령 수신
2. Primary가 "startIndexBuild" oplog 항목 생성
3. Secondary들이 oplog 복제 후 빌드 시작
4. 각 멤버가 빌드 완료하면 투표
5. 커밋 쿼럼 충족 시 Primary가 커밋
6. "commitIndexBuild" oplog 항목 생성
7. 모든 멤버가 인덱스 활성화
```

### 동작 흐름 시각화

```
시간 →

Primary:    [startIndexBuild] ────빌드────→ [쿼럼대기] → [commitIndexBuild]
                 ↓                              ↑              ↓
Secondary1: ─복제─→ [startIndexBuild] ─빌드─→ [투표]     ─복제─→ [완료]
                 ↓                              ↑              ↓
Secondary2: ─복제─→ [startIndexBuild] ─빌드─→ [투표]     ─복제─→ [완료]
```

### 투표 노드의 개념

"투표 노드(Voting Members)"는 `members[n].votes` 값이 0보다 큰 모든 복제본 세트 멤버를 의미한다.

```javascript
// 복제본 세트 설정 예시
{
  _id: "rs0",
  members: [
    { _id: 0, host: "mongo1:27017", votes: 1 },  // 투표 가능
    { _id: 1, host: "mongo2:27017", votes: 1 },  // 투표 가능
    { _id: 2, host: "mongo3:27017", votes: 0 }   // 투표 불가 (hidden 등)
  ]
}
```

### 커밋 쿼럼의 기본값

```
기본값: "votingMembers" (모든 데이터 보유 투표 멤버)

의미: Primary를 포함한 모든 투표 멤버가 빌드를 완료해야 
      인덱스가 "사용 가능" 상태가 됨
```

### 주의: 연결 불가 노드로 인한 빌드 중단

```
문제 상황:
  - commitQuorum = "votingMembers" (기본값)
  - Secondary 하나가 네트워크 문제로 연결 불가

결과:
  - 해당 노드가 온라인이 될 때까지 인덱스 빌드가 중단됨
  - Primary와 다른 Secondary는 무한 대기

해결책:
  - commitQuorum을 "majority" 또는 숫자로 변경
  - 네트워크 문제 해결
```

### 롤링 인덱스 빌드 vs 동시 인덱스 빌드

```
롤링 인덱스 빌드 (Rolling Index Build):
  - 한 번에 하나의 멤버만 빌드
  - Secondary부터 시작, Primary는 마지막
  - 각 멤버를 독립형으로 재시작 필요
  - 클러스터 복원력 저하

동시 인덱스 빌드 (Simultaneous Build):
  - 모든 멤버가 동시에 빌드
  - 더 빠르고 간단
  - 권장 방식

⚠️ 경고: 두 방식을 동시에 사용하면 빌드 손상, 충돌 발생 가능
```

---

## 7. 커밋 쿼럼(Commit Quorum) vs 쓰기 고려(Write Concern)

이 두 개념은 비슷해 보이지만 완전히 다른 목적으로 사용된다.

### 커밋 쿼럼 (Commit Quorum)

```
적용 대상: 인덱스 빌드
질문: "몇 명이 인덱스 빌드를 완료해야 커밋할까?"
시점: 인덱스가 "사용 가능"으로 표시되기 전

설정 방법:
db.collection.createIndex(
  { field: 1 },
  { },
  "majority"  // commitQuorum 옵션
)

가능한 값:
- "votingMembers": 모든 투표 멤버 (기본값)
- "majority": 과반수
- 숫자: 지정된 수의 멤버
- 0: 쿼럼 없음 (Primary만 완료하면 됨)
```

### 쓰기 고려 (Write Concern)

```
적용 대상: 일반 쓰기 작업
질문: "몇 개 노드에 데이터가 복제되어야 성공으로 볼까?"
시점: 쓰기 작업이 완료된 후

설정 방법:
db.collection.insertOne(
  { name: "test" },
  { writeConcern: { w: "majority" } }
)
```

### MongoDB 8.0에서의 변화

```
MongoDB 8.0 이전:
  - 쓰기 고려 = 인덱스 빌드를 "완료"해야 하는 노드 수

MongoDB 8.0 이후:
  - 쓰기 고려 = 인덱스 빌드 "oplog 항목을 복제"해야 하는 노드 수
  - 더 빠른 응답, 실제 빌드 완료와 분리
```

### 비교 표

| 구분 | 커밋 쿼럼 | 쓰기 고려 |
|------|----------|----------|
| 적용 대상 | 인덱스 빌드 | 쓰기 작업 |
| 기본값 | votingMembers | varies |
| 의미 | 빌드 완료 필요 수 | 복제 확인 필요 수 |
| 설정 명령 | createIndexes | insert, update 등 |

---

## 8. 제약 조건 위반과 인덱스 빌드 실패

### 언제 발생하는가?

인덱스가 컬렉션에 제약 조건을 부과할 때 발생할 수 있다.

```
제약 조건이 있는 인덱스 유형:
  - Unique 인덱스: 중복 값 불허
  - 2dsphere 인덱스: 유효한 GeoJSON 필요
  - Text 인덱스: 유효한 텍스트 필요
```

### 제약 조건 검사 시점

**핵심**: 제약 조건은 인덱스 빌드가 **완료된 후**에 검사된다.

```
시나리오: email 필드에 unique 인덱스 생성

단계 1: 빌드 시작
  - 중복된 email 값이 있어도 빌드는 시작됨
  - 제약 조건 위반 테이블에 기록

단계 2: 빌드 진행 중
  - 애플리케이션이 중복 email로 문서 추가 가능
  - 사이드 쓰기 테이블에 기록

단계 3: 빌드 완료 직전
  - 제약 조건 위반 테이블 검사
  - 여전히 중복 존재? → 빌드 실패, 에러 반환
  - 중복 해소됨? → 빌드 성공
```

### 빌드 실패를 방지하는 방법

```javascript
// 1. 빌드 전 중복 데이터 확인
db.collection.aggregate([
  { $group: { _id: "$email", count: { $sum: 1 } } },
  { $match: { count: { $gt: 1 } } }
])

// 2. 중복 데이터 정리
// ... 중복 제거 작업 ...

// 3. 빌드 중 쓰기 제한 (선택적)
// 애플리케이션 레벨에서 제어

// 4. 인덱스 생성
db.collection.createIndex({ email: 1 }, { unique: true })
```

---

## 9. 샤딩 환경에서의 인덱스 빌드

### 샤딩 환경의 특성

```
구조:
  mongos ─┬─ Shard1 (RS) ─ Primary, Secondary1, Secondary2
          ├─ Shard2 (RS) ─ Primary, Secondary1, Secondary2
          └─ Shard3 (RS) ─ Primary, Secondary1, Secondary2

인덱스 빌드 특성:
  - 해당 컬렉션의 데이터가 있는 샤드에서만 빌드 발생
  - 각 샤드는 독립적인 복제본 세트
  - 각 샤드 내에서 동시 빌드 프로세스 진행
```

### 불일치 인덱스 문제

샤딩 환경에서는 **인덱스 불일치(Inconsistent Index)** 문제가 발생할 수 있다.

```
문제 상황:
  - Shard1: unique 인덱스 생성 성공
  - Shard2: 중복 데이터로 인해 실패
  - Shard3: unique 인덱스 생성 성공

결과: 샤드 간 인덱스가 다름 → 쿼리 결과 불일치 가능
```

### 불일치 인덱스 해결

```javascript
// 1. 불일치 인덱스 확인
db.adminCommand({ listIndexes: "collection" })

// 2. mongos에서 인덱스 삭제 (모든 샤드에서 삭제됨)
db.collection.dropIndex("email_1")

// 3. 데이터 정리 후 재생성
```

### Config 서버의 자동 검사

```
MongoDB는 자동으로 샤드 간 인덱스 일관성을 검사한다.

설정 파라미터:
  - enableShardedIndexConsistencyCheck: 검사 활성화/비활성화
  - shardedIndexConsistencyCheckIntervalMS: 검사 주기

검사 결과 확인:
db.adminCommand({ serverStatus: 1 }).shardedIndexConsistency
```

---

## 10. 인덱스 빌드가 성능에 미치는 영향

### 쓰기 부하가 높은 상황에서의 문제

```
상황: 초당 1000건의 쓰기가 발생하는 컬렉션에서 인덱스 빌드

문제점:
  1. 사이드 쓰기 테이블이 빠르게 채워짐
  2. 빌드가 컬렉션 스캔보다 사이드 쓰기 처리에 더 많은 시간 소요
  3. 쓰기 성능 저하 (IX Lock 양보로 인한 경합)
  4. 전체 빌드 시간 증가

권장사항:
  - 쓰기 부하가 낮은 시간대에 빌드 수행
  - 유지보수 윈도우 활용
```

### 메모리 사용량

```
기본 메모리 제한: 200MB (createIndexes 명령당)

동작:
  - 메모리 내에서 키 정렬 수행
  - 한도 초과 시 --dbpath/_tmp에 임시 파일 생성
  - 디스크 I/O로 인해 빌드 속도 저하

여러 인덱스 동시 빌드 시:
  - 200MB를 인덱스 수로 나눔
  - 예: 4개 인덱스 빌드 → 각 50MB

파라미터: maxIndexBuildMemoryUsageMegabytes
```

### 메모리 설정 조정

```javascript
// 런타임에 변경 (세션 동안만 유효)
db.adminCommand({
  setParameter: 1,
  maxIndexBuildMemoryUsageMegabytes: 500
})

// mongod.conf에서 영구 설정
setParameter:
  maxIndexBuildMemoryUsageMegabytes: 500
```

### 최대 동시 인덱스 빌드 수

```
기본값: 3개

파라미터: maxNumActiveUserIndexBuilds

동작:
  - 한도 도달 시 추가 빌드 요청은 대기
  - 진행 중인 빌드가 완료되면 대기 중인 빌드 시작

메모리 고려:
  - 동시 빌드 3개 × 200MB = 최대 600MB
  - 동시 빌드 수를 늘리면 메모리 사용량도 증가
```

---

## 11. 빌드 실패와 복구 메커니즘

### MongoDB 5.0+ 복구 가능한 인덱스 빌드

MongoDB 5.0부터 인덱스 빌드 중 서버가 종료되어도 진행 상황이 보존된다.

```
조건:
  - commitQuorum이 기본값("votingMembers")인 경우
  - 정상적인 종료 (shutdown 또는 SIGTERM)

동작:
  1. 빌드 진행 상황이 디스크에 저장
  2. mongod 재시작 시 체크포인트에서 계속
  3. 처음부터 다시 시작할 필요 없음
```

### Primary에서의 복구

```
시나리오: Primary mongod가 인덱스 빌드 중 종료

과정:
  1. 빌드 진행 상황 디스크에 저장
  2. mongod 재시작
  3. 저장된 체크포인트에서 빌드 재개
  4. 완료 후 commitIndexBuild oplog 생성
```

### Secondary에서의 복구

```
시나리오: Secondary mongod가 인덱스 빌드 중 종료

과정:
  1. 빌드 진행 상황 디스크에 저장
  2. mongod 재시작
  3. 저장된 체크포인트에서 빌드 재개
  4. Primary의 commitIndexBuild oplog 대기

주의: 
  - Secondary를 독립형으로 재시작하면 빌드 일시 중지
  - 수동으로 dropIndex 해야 함
```

### 독립형(Standalone)에서의 빌드 실패

```
시나리오: 복제본 세트가 아닌 단일 mongod

동작:
  - 종료 시 빌드 작업과 진행 상황 모두 손실
  - 재시작 후 createIndex를 다시 실행해야 함

이유: 복구 가능 빌드는 복제본 세트 기능에 의존
```

### 롤백 중 인덱스 빌드

```
시나리오: 인덱스 빌드 중 롤백 발생

동작:
  1. 진행 중인 인덱스 빌드 일시 중지
  2. 롤백 수행
  3. 롤백이 인덱스 빌드를 되돌리지 않으면 → 빌드 재개
  4. 롤백이 인덱스 빌드를 되돌리면 → 인덱스 재생성 필요
```

### 로그에서 복구 확인

```
# 빌드 중단 시
"msg":"Index build: wrote resumable state to disk"

# 재시작 후 복구 시
"msg":"Found index from unfinished build"
```

---

## 12. 인덱스 빌드 모니터링과 종료

### 진행 중인 빌드 모니터링

```javascript
// 모든 인덱스 빌드 작업 조회
db.currentOp({ "command.createIndexes": { $exists: true } })

// 특정 컬렉션의 빌드 조회
db.currentOp({
  $or: [
    { op: "command", "command.createIndexes": "myCollection" },
    { op: "none", "msg": /Index Build/ }
  ]
})
```

### currentOp 결과 해석

```javascript
{
  "opid": 12345,
  "active": true,
  "op": "command",
  "command": {
    "createIndexes": "users",
    "indexes": [{ "key": { "email": 1 }, "name": "email_1" }]
  },
  "msg": "Index Build: inserted 500000 keys from external sorter into index",
  "progress": {
    "done": 500000,
    "total": 1000000
  }
  // ...
}
```

### msg 필드의 단계 표시

```
가능한 msg 값들:
- "Index Build: scanning collection"
- "Index Build: inserted X keys from external sorter into index"
- "Index Build: draining side write table"
- "Index Build: waiting for commit quorum"
- "Index Build: committing"
```

### 진행 중인 빌드 종료

```javascript
// dropIndex로 진행 중인 빌드 종료
db.collection.dropIndex("email_1")

// 또는 dropIndexes
db.runCommand({
  dropIndexes: "collection",
  index: "email_1"
})
```

### ⚠️ 주의: killOp 사용 금지

```
❌ 잘못된 방법:
db.killOp(12345)  // 인덱스 빌드 opid

이유:
  - 복제본 세트에서 불일치 상태 발생 가능
  - 일부 노드만 빌드 중단, 다른 노드는 계속 진행
  - 데이터 손상 가능

✅ 올바른 방법:
db.collection.dropIndex("index_name")
  - 모든 노드에서 안전하게 빌드 중단
  - abortIndexBuild oplog 항목 생성
```

---

## 13. MongoDB 7.1 이후 개선 사항

MongoDB 7.1에서 인덱스 빌드가 크게 개선되었다.

### 빠른 오류 보고

```
이전 (MongoDB 7.0 이하):
  - 오류가 커밋 단계에서 보고됨
  - 빌드가 거의 끝날 때까지 오류를 알 수 없음
  - 시간 낭비

이후 (MongoDB 7.1+):
  - 컬렉션 스캔 단계에서 즉시 오류 보고
  - 중복 키 오류 제외한 대부분의 오류가 즉시 반환
  - 빠른 진단 가능
```

### Secondary 충돌 방지

```
이전 (MongoDB 7.0 이하):
  - Secondary에서 인덱스 빌드 오류 → Secondary 충돌
  - 클러스터 안정성 저하

이후 (MongoDB 7.1+):
  - Secondary가 Primary에게 "빌드 중단 요청" 가능
  - Secondary 충돌 방지
  - 단, 이미 커밋에 투표한 경우는 예외
```

### 디스크 공간 관리

```
새 파라미터: indexBuildMinAvailableDiskSpaceMB

동작:
  - 사용 가능한 디스크 공간 모니터링
  - 지정된 최소값 미만이면 자동으로 빌드 중단
  - 디스크 풀 상황 방지

설정:
db.adminCommand({
  setParameter: 1,
  indexBuildMinAvailableDiskSpaceMB: 5000  // 5GB
})
```

### 버전별 비교 표

| 기능 | MongoDB 7.0 이하 | MongoDB 7.1+ |
|------|-----------------|--------------|
| 오류 보고 시점 | 커밋 단계 (늦음) | 스캔 단계 (빠름) |
| Secondary 오류 처리 | 충돌 | 중단 요청 |
| 디스크 공간 관리 | 없음 | 자동 중단 |

---

## 14. 실무 적용 가이드

### 인덱스 빌드 전 체크리스트

```
□ 대상 컬렉션의 문서 수 확인
  db.collection.estimatedDocumentCount()

□ unique 인덱스인 경우 중복 데이터 확인
  db.collection.aggregate([
    { $group: { _id: "$field", count: { $sum: 1 } } },
    { $match: { count: { $gt: 1 } } }
  ])

□ 현재 쓰기 부하 확인
  db.serverStatus().opcounters

□ 가용 메모리 확인
  db.serverStatus().mem

□ 디스크 공간 확인 (MongoDB 7.1+)
  df -h /data/db

□ 유지보수 윈도우 확보 (권장)
```

### 빌드 시작 모범 사례

```javascript
// 1. 적절한 commitQuorum 설정 (복제본 세트)
db.collection.createIndex(
  { email: 1 },
  { unique: true },
  "majority"  // 모든 멤버 대기 대신 과반수만
)

// 2. 백그라운드에서 진행 상황 모니터링
// (다른 세션에서)
while (true) {
  const ops = db.currentOp({ "command.createIndexes": "collection" });
  if (ops.inprog.length === 0) break;
  print(ops.inprog[0].msg);
  sleep(5000);
}

// 3. 완료 확인
db.collection.getIndexes()
```

### 긴급 상황 대응

```javascript
// 빌드가 너무 오래 걸릴 때
// 1. 진행 상황 확인
db.currentOp({ "command.createIndexes": { $exists: true } })

// 2. 빌드 중단 결정 시
db.collection.dropIndex("index_name")

// 3. 더 나은 시간대에 재시도
```

### 프로덕션 권장 설정

```yaml
# mongod.conf

# 인덱스 빌드 메모리 (기본 200MB)
setParameter:
  maxIndexBuildMemoryUsageMegabytes: 500
  
  # MongoDB 7.1+ 디스크 공간 최소값 (5GB)
  indexBuildMinAvailableDiskSpaceMB: 5000
  
  # 동시 빌드 수 (기본 3)
  maxNumActiveUserIndexBuilds: 3
```

### 알람 설정 권장 사항

```
모니터링 대상:
  1. 인덱스 빌드 소요 시간
  2. 사이드 쓰기 테이블 크기 (급격한 증가 시 쓰기 부하 높음)
  3. 디스크 공간 사용량
  4. 복제 지연 (인덱스 빌드로 인한)
```

---

## 15. 핵심 요약

### 한 장 요약

```
┌─────────────────────────────────────────────────────────────────────┐
│                    MongoDB 인덱스 빌드 핵심 요약                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. 잠금은 시작과 끝에만 짧게                                         │
│     → 대부분의 시간은 읽기/쓰기 가능                                   │
│                                                                     │
│  2. 빌드 중 쓰기는 사이드 쓰기 테이블이 처리                           │
│     → 나중에 인덱스에 반영                                            │
│                                                                     │
│  3. 제약 조건(unique 등)은 빌드 완료 시점에 검사                       │
│     → 빌드 중에는 위반 가능, 완료 시 위반 있으면 실패                   │
│                                                                     │
│  4. 복제본 세트는 동시에 빌드, 쿼럼으로 커밋                           │
│     → 커밋 쿼럼 ≠ 쓰기 고려                                           │
│                                                                     │
│  5. MongoDB 5.0+는 빌드 진행 상황 복구 가능                           │
│     → 종료 후 재시작해도 이어서 진행                                   │
│                                                                     │
│  6. 빌드 중단은 dropIndex로                                          │
│     → killOp 사용 금지!                                              │
│                                                                     │
│  7. 쓰기 부하 낮은 시간대에 빌드 권장                                  │
│     → 유지보수 윈도우 활용                                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 요약 정리

**인덱스 빌드 중에 서비스가 중단되는지?**

A: No. 시작과 끝에 아주 짧은 독점 잠금만 있고, 대부분의 시간은 읽기/쓰기가 가능

**빌드 중에 새 데이터를 추가하면 어떻게 되는지?**

A: 사이드 쓰기 테이블에 저장되었다가 인덱스 정리가 끝난시점 반영.

**unique 인덱스 빌드 시 중복 데이터가 있으면?**

A: 빌드는 시작되지만, 완료 시점에 중복이 남아있으면 에러와 함께 빌드가 실패

**복제본 세트에서 한 노드만 빌드에 실패하면?**

A: 해당 인덱스 빌드 전체가 실패. abortIndexBuild oplog가 생성되어 모든 노드에서 빌드가 중단.

**빌드 중에 서버가 종료되면?**

A: MongoDB 5.0+에서는 진행 상황이 저장되어, 재시작 후 이어서 빌드합니다. 그 이전 버전에서는 처음부터 다시 시작

**Q: 빌드 진행 상황을 어떻게 확인하나요?**

A: `db.currentOp()`를 사용. msg 필드에 현재 단계와 진행률이 표시.

**Q: 빌드를 중단하고 싶으면?**

A: `db.collection.dropIndex("index_name")`을 사용 `killOp`는 사용 X.

---

## 참고 자료

- [MongoDB 공식 문서 - Index Builds on Populated Collections](https://www.mongodb.com/docs/manual/core/index-creation/)
- [MongoDB 공식 문서 - Rolling Index Builds](https://www.mongodb.com/docs/manual/core/rolling-index-builds/)
- [MongoDB 공식 문서 - db.currentOp()](https://www.mongodb.com/docs/manual/reference/method/db.currentOp/)

---
