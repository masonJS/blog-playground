## OpenSearch 문서 딥다이빙

### 텍스트 분석

전체 텍스트 검색을 사용할 때, “walk”를 검색하면 “Walk”, “walked”, “walking” 등 다양한 형태의 단어가 포함된 결과를 모두 받고 싶을 것입니다. 이를 위해 OpenSearch는 텍스트 분석을 사용합니다.

텍스트 분석의 목적은 소스 문서의 비정형 자유 텍스트를 일련의 용어(terms)로 분할하여, 이를 역색인(inverted index)에 저장하는 것입니다. 이후 사용자의 쿼리에도 유사한 텍스트 분석을 적용하여, 생성된 용어 시퀀스를 통해 관련 소스 문서를 매칭합니다.

기술적으로 텍스트 분석 과정은 여러 단계로 이루어지며, 일부 단계는 선택적입니다.
1. 자유 텍스트를 개별 단어로 분할하기 전에, 문자 수준에서 텍스트를 다듬는 것이 유용할 수 있습니다. 이 단계의 주요 목적은 토크나이저(tokenizer)가 더 나은 토큰을 생성하도록 돕는 것입니다. 예를 들어, 마크업 태그(HTML) 제거, 특정 문자 패턴 처리(🙂 이모지를 ‎⁠:slightly_smiling_face:⁠로 변환) 등이 있습니다.
2. 다음 단계는 자유 텍스트를 개별 단어(토큰)로 분할하는 것입니다. 이는 토크나이저가 수행합니다. 예를 들어, ‎⁠Actions speak louder than words⁠라는 문장은 ‎⁠Actions⁠, ‎⁠speak⁠, ‎⁠louder⁠, ‎⁠than⁠, ‎⁠words⁠라는 토큰으로 분할됩니다.
3. 마지막 단계는 개별 토큰을 일련의 토큰 필터(token filter)를 통해 처리하는 것입니다. 각 토큰을 예측 가능한 형태로 변환하여 인덱스에 직접 저장합니다. 예를 들어, 대문자를 소문자로 변환하거나, 어간 추출(stemming)을 수행합니다. ‎⁠Actions⁠는 ‎⁠action⁠, ‎⁠louder⁠는 ‎⁠loud⁠, ‎⁠words⁠는 ‎⁠word⁠로 변환됩니다.

> **토큰(token)**과 **용어(term)**는 비슷하게 들릴 수 있지만, Apache Lucene에서는 각각의 역할이 다릅니다. 토큰은 텍스트 분석 중 토크나이저에 의해 생성되며, 추가적인 수정 과정을 거칩니다. 각 토큰은 메타데이터와 함께 분석 과정에서 사용됩니다. 용어는 역색인에 직접 저장되는 데이터 값으로, 메타데이터가 훨씬 적습니다. 검색 시에는 용어 단위로 매칭이 이루어집니다.


#### 분석기(Analyzer)

OpenSearch에서 텍스트 분석을 포괄하는 추상화 개념은 **분석기(analyzer)**입니다. 각 분석기는 다음과 같은 순차적 구성 요소를 포함합니다.
1. 문자 필터(Character filter): 원본 텍스트를 문자 스트림으로 받아 문자 추가, 제거, 수정 작업을 수행합니다. 예를 들어, HTML 태그를 제거하여 `<p><b>Actions</b> speak louder than <em>words</em></p>`을 `\nActions speak louder than words\n`로 변환합니다.
2. 토크나이저(Tokenizer): 문자 필터로 처리된 문자 스트림을 받아 개별 토큰(보통 단어)으로 분할합니다. 예를 들어, 공백 기준으로 분할하여 [‎`Actions`, ‎`speak`, ‎`louder`, ‎`than`, ‎`words`]와 같이 만듭니다. 토크나이저는 토큰의 시작/끝 위치 등 메타데이터도 유지합니다.
3. 토큰 필터(Token filter): 토크나이저에서 생성된 토큰 스트림을 받아 토큰을 추가, 제거, 수정합니다. 예를 들어, 토큰을 소문자로 변환(‎⁠Actions⁠ → ‎⁠action⁠), 불용어(stopword) 제거(‎⁠than⁠), 동의어 추가(‎⁠speak⁠ → ‎⁠talk⁠) 등이 가능합니다.

분석기는 반드시 하나의 토크나이저를 포함해야 하며, 문자 필터와 토큰 필터는 0개 이상 포함할 수 있습니다.

**정규화기(normalizer)**라는 특별한 유형의 분석기도 있습니다. 정규화기는 토크나이저를 포함하지 않으며, 특정 문자 필터와 토큰 필터만 사용할 수 있습니다. 이 필터들은 문자 수준의 작업만 수행하며, 토큰 전체에 대한 작업(동의어 처리, 어간 추출 등)은 지원하지 않습니다.


#### 인덱싱 시점과 쿼리 시점의 텍스트 분석

OpenSearch는 문서를 인덱싱할 때와 검색 요청을 보낼 때 텍스트 필드에 대해 텍스트 분석을 수행합니다. 분석 시점에 따라 분석기는 다음과 같이 분류됩니다.  
• 인덱스 분석기(index analyzer): 인덱싱 시점에 텍스트 필드를 분석합니다. 인덱스 분석기 지정 방법은 “Index analyzers”를 참고하세요.  
• 검색 분석기(search analyzer): 쿼리 시점에 쿼리 문자열을 분석합니다. 검색 분석기 지정 방법은 “Search analyzers”를 참고하세요.

대부분의 경우, 인덱싱과 검색 시점에 동일한 분석기를 사용하는 것이 좋습니다. 그래야 텍스트 필드와 쿼리 문자열이 동일하게 분석되어 토큰이 일치합니다.

예시

`Actions speak louder than words`라는 텍스트 필드를 인덱싱하면 다음과 같은 토큰이 생성됩니다:

텍스트 필드 토큰 = [‎`action`, ‎`speak`, ‎`loud`, ‎`than`, ‎`word`]

`speaking loudly`라는 쿼리로 검색하면 다음과 같은 토큰이 생성됩니다:

쿼리 문자열 토큰 = [‎`speak`, ‎`loud`]

OpenSearch는 쿼리 토큰과 텍스트 필드 토큰을 비교하여, 두 리스트 모두에 `speak`와 `loud`가 포함되어 있으므로 해당 문서를 검색 결과로 반환합니다.


### OpenSearch Refresh Interval

OpenSearch에서 문서를 인덱싱하면, 문서는 처음에 메모리 버퍼에 저장됩니다.   
이 단계에서는 문서가 아직 검색 가능하지 않습니다.     
문서를 검색 가능하게 만들려면 refresh 작업이 필요합니다.  
이 작업은 문서를 메모리 버퍼에서 새로운 세그먼트로 옮깁니다.     
세그먼트는 OpenSearch가 문서를 저장하고 검색할 때 사용하는 데이터 구조입니다.
문서가 세그먼트에 저장되면 검색이 가능합니다.   
```
Segment란 무엇인가?

OpenSearch에서 Segment(세그먼트)는 Lucene 엔진이 인덱스 샤드 내에 생성하는 불변(immutable) 데이터 파일입니다. 
문서가 인덱싱될 때, 이들은 메모리 버퍼에 저장되고, refresh 작업이 발생하면 새로운 세그먼트로 변환되어 디스크에 기록됩니다. 
세그먼트는 검색 시 실제로 데이터를 읽고 처리하는 단위이기도 합니다. 
세그먼트는 한 번 생성되면 변경되지 않으며, 새로운 문서가 추가되거나 삭제될 때마다 새로운 세그먼트가 생성됩니다. 
일정 시간이 지나면 여러 세그먼트가 병합(merge)되어 더 큰 세그먼트로 합쳐집니다.

```

refresh 작업은 문서를 세그먼트로 옮겨 검색 가능하게 만드는 과정이며, OpenSearch가 자동으로 관리합니다.   
기본적으로 OpenSearch는 지난 30초 동안 하나 이상의 검색 요청을 받은 인덱스에 대해 1초마다 refresh를 수행합니다.    
즉, 활성 인덱스에 기록된 문서는 일반적으로 1초 이내에 검색 가능해집니다. 인덱스의 기본 refresh 빈도는 1초로 설정되어 있지만, 인덱스별로 조정할 수 있습니다.  


refresh 작업은 많은 리소스를 소모합니다.   
데이터를 새로운 세그먼트로 옮기고 검색 가능하게 만드는 과정은 CPU, 메모리, I/O 리소스를 필요로 합니다.  
따라서 refresh 작업을 줄이면 이러한 리소스를 다른 작업에 사용할 수 있습니다.

하지만 refresh 빈도를 낮추면 새로 인덱싱된 문서가 검색 가능해지기까지 더 오래 기다려야 합니다.    
새로운 데이터를 거의 실시간으로 검색해야 하는 경우, refresh 빈도를 낮추는 것은 적합하지 않을 수 있습니다.     
반면, 데이터 인덱싱과 검색 사이에 지연을 허용할 수 있다면 refresh 빈도를 줄여 리소스를 확보할 수 있습니다. 이는 인덱싱 처리량 증가와 더 빠른 인덱싱 속도로 이어질 수 있습니다.



### OpenSearch DSL 모음집

````bash
## 생성된 index가 있는지 확인
GET _cat/indices?v

## 설치된 플러그인이 있는지 확인
GET _cat/plugins?v



````
