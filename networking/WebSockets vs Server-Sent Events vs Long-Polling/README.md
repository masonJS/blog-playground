# WebSockets vs Server-Sent Events vs Long-Polling: 실시간 웹 통신의 모든 것

현대 웹 애플리케이션에서 서버가 클라이언트에게 실시간으로 데이터를 전송하는 것은 필수적인 기능이 되었습니다. 채팅 앱, 주식 시세 표시, 라이브 스코어보드 등 우리가 매일 사용하는 서비스들은 모두 이 기술에 의존합니다. 그런데 이를 구현하는 방법은 하나가 아닙니다. 오늘은 가장 널리 쓰이는 세 가지 방식인 Long-Polling, WebSockets, Server-Sent Events(SSE)를 깊이 있게 비교해보겠습니다.

---

## 1. Long-Polling: 최초의 실시간 통신 "꼼수"

### 작동 원리

Long-Polling은 실시간 통신을 위한 최초의 "해킹적" 접근법입니다. 일반적인 폴링(Polling)이 주기적으로 서버에 "새 데이터 있어?"라고 묻는 방식이라면, Long-Polling은 조금 더 영리합니다.

클라이언트가 서버에 요청을 보내면, 서버는 새로운 데이터가 생길 때까지 응답을 보류합니다. 데이터가 준비되면 그때서야 응답을 보내고 연결을 종료합니다. 클라이언트는 응답을 받자마자 즉시 새로운 요청을 시작하고, 이 과정이 반복됩니다.

```javascript
// Long-Polling 클라이언트 구현
function longPoll() {
    fetch('http://example.com/poll')
        .then(response => response.json())
        .then(data => {
            console.log("데이터 수신:", data);
            longPoll(); // 즉시 새로운 요청 시작
        })
        .catch(error => {
            // 타임아웃이나 네트워크 오류 시 잠시 후 재시도
            setTimeout(longPoll, 10000);
        });
}
longPoll();
```

### 장점과 한계

클라이언트 측 구현은 위 코드처럼 단순합니다. 하지만 서버 측에서는 이야기가 달라집니다. 클라이언트가 재연결하는 동안 발생한 이벤트를 놓치지 않도록 보장하는 것이 까다롭습니다. 또한 연결을 반복적으로 열고 닫는 과정에서 발생하는 오버헤드가 상당합니다.

**Long-Polling은 현재 대부분의 경우 구식 기술로 간주됩니다.** WebSocket이나 SSE를 사용할 수 없는 레거시 환경에서의 폴백(fallback) 용도로만 권장됩니다.

---

## 2. WebSockets: 양방향 통신의 표준

### 작동 원리

WebSocket은 클라이언트와 서버 간에 단일 연결을 통해 완전한 양방향(full-duplex) 통신을 제공합니다. HTTP 요청-응답 사이클의 오버헤드 없이 양측이 독립적으로 데이터를 주고받을 수 있어, 낮은 지연시간과 높은 빈도의 업데이트가 필요한 시나리오에 이상적입니다.

```javascript
// WebSocket 클라이언트 구현
const socket = new WebSocket('ws://example.com');

socket.onopen = function(event) {
    console.log('연결 성립');
    socket.send('안녕하세요, 서버!');
};

socket.onmessage = function(event) {
    console.log('서버로부터의 메시지:', event.data);
};
```

### 현실 세계의 복잡성

기본 API는 간단해 보이지만, 프로덕션 환경에서는 상당히 복잡해집니다.

소켓 연결은 언제든 끊어질 수 있고, 그에 맞춰 재생성해야 합니다. 특히 **연결이 아직 유효한지 판단하는 것이 매우 까다롭습니다.** 대부분의 경우 열린 연결이 닫히지 않았는지 확인하기 위해 ping-pong 하트비트를 추가해야 합니다.

이러한 복잡성 때문에 대부분의 개발자들은 Socket.IO 같은 라이브러리를 사용합니다. 이 라이브러리는 연결 관리의 모든 케이스를 처리하고, 필요시 Long-Polling으로의 폴백까지 제공합니다.

### Socket.IO에 대한 현실적인 시각

Socket.IO는 WebSocket을 쉽게 사용할 수 있게 해주는 인기 있는 라이브러리입니다. 하지만 실무 경험을 가진 개발자들 사이에서는 의견이 갈립니다.

**Socket.IO의 장점:**
- 자동 재연결, 하트비트 등을 기본 제공
- Long-Polling 폴백 지원
- Room, Namespace 등 고수준 추상화

**하지만 고려해야 할 점:**
- 페이로드 크기가 상당히 증가함
- 하트비트와 재연결은 직접 구현해도 코드 몇 줄이면 충분함
- 현대 브라우저에서 WebSocket이 잘 지원되므로 Long-Polling 폴백의 필요성이 줄어듦

한 개발자의 표현을 빌리자면: "Socket.IO는 예전에 특정 브라우저가 WebSocket을 지원하지 않을 때 유용했지만, 지금은 주로 소켓이 두려운 사람들이 사용한다."

---

## 3. Server-Sent Events (SSE): 단방향의 간결함

### 작동 원리

SSE는 HTTP를 통해 서버에서 클라이언트로 업데이트를 푸시하는 표준적인 방법입니다. WebSocket과 달리 **서버에서 클라이언트로의 단방향 통신만** 지원하므로, 실시간 뉴스 피드나 스포츠 점수 업데이트처럼 클라이언트가 데이터를 전송할 필요 없이 서버 업데이트만 받으면 되는 시나리오에 적합합니다.

SSE를 한마디로 표현하면: **서버가 응답 본문을 한 번에 보내지 않고, 연결을 열어둔 채로 이벤트가 발생할 때마다 한 줄씩 보내는 단일 HTTP 요청**입니다.

```javascript
// SSE 클라이언트 구현
const evtSource = new EventSource("https://example.com/events");

evtSource.onmessage = event => {
    console.log('메시지 수신: ' + event.data);
};
```

WebSocket과 달리 **EventSource는 연결이 끊어지면 자동으로 재연결을 시도합니다.** 이것이 SSE의 큰 장점 중 하나입니다.

### 서버 측 구현 (Node.js Express)

```javascript
import express from 'express';
const app = express();

app.get('/events', (req, res) => {
    res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
    });

    const sendEvent = (data) => {
        // 모든 메시지는 'data: '로 시작해야 함
        res.write(`data: ${JSON.stringify(data)}\n\n`);
    };

    // 2초마다 이벤트 전송
    const intervalId = setInterval(() => {
        sendEvent({
            time: new Date().toTimeString(),
            message: '서버에서 보내는 메시지!'
        });
    }, 2000);

    req.on('close', () => {
        clearInterval(intervalId);
        res.end();
    });
});
```

### 실제 프로덕션 사례: MMO 게임 백엔드

흥미롭게도 SSE는 단순한 알림 시스템을 넘어 **실시간 멀티플레이어 게임에서도 성공적으로 사용**되고 있습니다. Steam에서 출시된 MMO 게임 "Meadow"의 백엔드가 SSE를 HTTP/1.1 위에서 구현하여 6년간 35만 명의 플레이어를 처리했습니다.

개발자에 따르면:
- 출시 당시 **심각한 버그가 단 하나도 없었음** (UTF-8 클라이언트 버그 하나를 15분 만에 패치)
- 멀티플레이어 기능 구현에 **단 6주**만 소요
- 99.6%의 성공적인 네트워킹 달성

이 사례가 증명하듯, SSE는 올바르게 구현되면 매우 높은 안정성과 확장성을 제공할 수 있습니다.

---

## 실무에서 발견한 숨겨진 문제들

### EventSource API의 헤더 제한 문제

SSE의 가장 큰 실무적 문제 중 하나는 **브라우저의 네이티브 EventSource API가 커스텀 헤더를 지원하지 않는다**는 점입니다.

토큰 기반 인증을 사용하고 세션 쿠키를 피하고 싶다면, 인증 토큰을 보낼 수 없어서 곤란해집니다. URL 파라미터에 토큰을 넣는 것은 보안상 권장되지 않습니다(서버 로그, 프록시 캐시에 노출 위험).

**해결책:**
- `eventsource` 폴리필 라이브러리 사용 (커스텀 헤더 지원)
- Microsoft의 `fetch-event-source` 라이브러리 사용 (POST 요청과 body 데이터 지원)
- JWT를 `SameSite=strict`, `httpOnly`, `secure` 옵션이 적용된 세션 쿠키에 저장

한 개발자의 조언: "토큰을 쓰면서 세션 쿠키를 피하고 싶다면, 그건 자초한 문제다. JWT를 세션 쿠키에 저장하면 SSE와 완벽하게 호환된다."

### 하트비트의 중요성

SSE든 WebSocket이든, **하트비트 메커니즘은 필수**입니다. 여러 실무 경험에서 공통적으로 지적되는 사항입니다.

> "서버/클라이언트가 자체 하트비트를 구현해야 끊어진 연결을 감지하고 자동 재연결할 수 있다. 이것이 우리가 찾은 유일하게 신뢰할 수 있는 방법이다."

EventSource가 자동 재연결을 지원한다고 해도, **연결이 끊어졌다는 것을 감지하는 것 자체가 문제**입니다. 서버가 더 이상 데이터를 푸시할 수 없는 상태인데도 EventSource는 여전히 연결되어 있다고 생각할 수 있습니다.

주기적인 하트비트(예: "noop" 메시지)를 보내서 연결이 실제로 살아있는지 확인하는 것이 가장 확실한 방법입니다.

### 안티바이러스/프록시 버퍼링 문제

실무에서 종종 발견되는 문제 중 하나는 **일부 안티바이러스 소프트웨어와 프록시가 `text/event-stream` MIME 타입을 버퍼링**한다는 것입니다.

이들은 "전체" 응답이 완료될 때까지 기다리려 하는데, SSE는 기술적으로 끝나지 않는 응답입니다.

**해결책:**
1. 연결 직후 즉시 이벤트를 보내고, 짧은 타임아웃 내에 클라이언트에 도착하는지 확인
2. 도착하지 않으면 서버가 매 메시지 후 연결을 닫도록 전환 (연결 종료 시 AV가 응답을 통과시킴)
3. 클라이언트는 자동으로 재연결

또 다른 방법은 초기 청크에 "더미 데이터"를 많이 보내서 버퍼를 채우는 것입니다.

### HTTP/2에서의 Head-of-Line Blocking

HTTP/2는 멀티플렉싱으로 6개 연결 제한을 해결하지만, 새로운 문제를 도입합니다: **TCP 수준의 Head-of-Line Blocking**.

HTTP/2에서 패킷이 손실되면 그 연결에 멀티플렉싱된 **모든 요청이 지연**됩니다. 반면 WebSocket은 각각 별도의 TCP 연결을 사용하므로 이 문제에서 자유롭습니다.

이것이 HTTP/3(QUIC)가 개발된 이유 중 하나입니다. QUIC는 UDP 기반이므로 패킷 손실이 다른 스트림에 영향을 주지 않습니다.

그러나 현실적으로 **패킷 손실이 없다면 head-of-line blocking도 없습니다.** 혼잡한 네트워크나 셀룰러 서비스의 가장자리가 아니라면 큰 문제가 아닐 수 있습니다.

---

## 기술별 제약사항 비교

### 양방향 통신

| 기술 | 양방향 지원 |
|------|-------------|
| WebSocket | ✅ 완전 지원 |
| SSE | ❌ 서버→클라이언트만 |
| Long-Polling | ⚠️ 별도 HTTP 요청 필요 |

SSE는 기본 EventSource API로는 POST 본문 데이터를 보낼 수 없습니다. 하지만 HTTP/2를 사용한다면, **클라이언트의 AJAX 요청도 이미 열린 HTTP/2 연결을 통해 전송**되므로 새 연결이나 핸드셰이크 없이 WebSocket과 비슷한 지연시간을 달성할 수 있습니다.

### 6개 연결 제한 문제

대부분의 현대 브라우저는 **도메인당 6개의 연결만 허용**합니다. 이 제한은 브라우저 탭 간에도 공유됩니다. 즉, 같은 페이지를 여러 탭에서 열면 6개의 연결 풀을 나눠 써야 합니다.

**예시 문제 상황:** Grafana 대시보드를 여러 화면에서 여러 탭으로 열어두면 SSE 연결 한도에 금방 도달합니다.

**해결책들:**
1. **HTTP/2 또는 HTTP/3 사용**: 단일 연결에서 멀티플렉싱으로 약 100개의 동시 스트림 지원
2. **BroadcastChannel + 리더 선출**: 탭 간 통신을 통해 하나의 탭만 SSE 연결을 유지하고 나머지는 이를 공유
3. **여러 서브도메인 사용**: HTTP/1.1 환경에서의 워크어라운드

참고로 WebSocket도 연결 제한이 있지만, Chrome 기준 도메인당 255개, Firefox는 200개로 훨씬 여유롭습니다.

### 모바일 앱에서의 연결 유지

Android와 iOS 같은 모바일 OS는 일정 시간 비활성 후 앱을 백그라운드로 전환하며, 이 과정에서 열린 연결이 닫힙니다. 이는 배터리 절약과 성능 최적화를 위한 정책입니다.

따라서 모바일 환경에서는 **푸시 알림**이 서버에서 클라이언트로 데이터를 보내는 더 효율적이고 신뢰성 있는 방법입니다.

### 기업 환경의 프록시와 방화벽

엔터프라이즈 환경에서는 많은 프록시와 방화벽이 비-HTTP 연결을 차단합니다. 이 때문에 **WebSocket 서버를 인프라에 통합하기 어려운 경우가 많습니다.** 반면 SSE는 일반 HTTP를 사용하므로 기업 환경에서 더 쉽게 통합할 수 있습니다.

흥미롭게도 ISP에 따라 동작이 달라질 수 있습니다. 어떤 ISP는 오래 지속되는 HTTP 연결을 끊지만 WebSocket은 허용하고, 다른 ISP는 그 반대일 수 있습니다. 이건 운의 문제이며, 언제든 정책이 바뀔 수 있습니다.

---

## 성능 비교

### 지연시간 (Latency)

| 기술 | 특성 |
|------|------|
| WebSocket | 단일 영구 연결로 **가장 낮은 지연시간** |
| SSE | 서버→클라이언트 통신에서 낮은 지연시간 |
| Long-Polling | 새 연결마다 오버헤드 발생, **가장 높은 지연시간** |

Long-Polling의 경우, 클라이언트가 재연결 중일 때 서버가 이벤트를 보내려 하면 지연이 크게 증가할 수 있습니다.

**HTTP/2에서의 SSE 클라이언트→서버 지연시간:**
HTTP/2를 사용하면 브라우저가 도메인당 TCP 연결을 열어두고 여러 스트림을 멀티플렉싱합니다. SSE 스트림이 하나의 스트림이고, 클라이언트가 서버에 AJAX 요청을 보내면 **이미 열린 HTTP/2 연결을 통해** 전송됩니다. 새 연결이 필요 없고, 비용이 많이 드는 핸드셰이크도 없습니다.

### 처리량 (Throughput)

| 기술 | 특성 |
|------|------|
| WebSocket | 영구 연결로 높은 처리량, 단 백프레셔(backpressure) 문제 가능 |
| SSE | 오버헤드가 적어 브로드캐스트에 효율적 |
| Long-Polling | 잦은 연결 개폐로 **가장 낮은 처리량** |

### 확장성 (Scalability)

| 기술 | 특성 |
|------|------|
| WebSocket | Pub/Sub 솔루션과 상태 변경 컨트롤러 필요, 복잡한 확장 |
| SSE | 프로토콜 업그레이드 불필요, 상대적으로 단순한 확장 |
| Long-Polling | 잦은 연결로 **확장성 최하**, 폴백으로만 권장 |

WebSocket은 확장 시 Pub/Sub 솔루션(예: Redis)과 공유 상태 변경을 발행하는 컨트롤러가 필요합니다. 반면 SSE는 상대적으로 더 단순합니다.

### 대량 브로드캐스트 시나리오에서의 경험

2000개 이상의 활성 연결에서 1000ms 미만의 지연시간이 필요한 프로젝트에서 한 개발자는 **SSE에서 WebSocket으로 전환**해야 했습니다. 그 이유는:

- SSE에서는 브로드캐스트할 연결 배열을 순회하는 데 시간이 너무 오래 걸림
- 시간에 민감한 데이터가 일부 클라이언트에 몇 초 지연되어 도착
- WebSocket에서는 연결 끊김이 있었지만 데이터는 제시간에 도착

단, 이것은 **구현 문제일 가능성**이 있습니다. SSE 자체의 본질적인 한계가 아니라 사용한 구현체의 문제였을 수 있습니다.

---

## 디버깅에 대한 현실적인 이야기

### Firefox DevTools의 SSE 디버깅 문제

Firefox에서 SSE를 디버깅하는 것은 오랫동안 어려웠습니다. Firefox 82부터 SSE 스트림 검사가 가능해졌지만, 현실은 조금 다릅니다.

실제로 테스트해보면 **서버가 SSE 연결을 닫은 후에만** 이벤트가 DevTools에 나타나는 경우가 있습니다. 디버깅에는 별로 유용하지 않습니다. Chrome DevTools는 같은 상황에서 잘 작동합니다.

### Fetch API로 SSE 직접 구현

Fastmail(유명한 이메일 서비스)은 SSE를 사용하지만, **네이티브 EventSource 대신 fetch나 XMLHttpRequest 위에 직접 구현**합니다. 이유는:

- 타임아웃/연결 끊김/재연결에 대한 더 나은 제어
- `Last-Event-ID` 처리
- 오래된 브라우저의 버그 회피

이 접근법은 모든 경우에 권장되지는 않지만, 고급 제어가 필요한 경우 고려해볼 만합니다.

---

## 실무 권장사항

### SSE를 선택해야 할 때

- 서버에서 클라이언트로의 단방향 업데이트가 주된 요구사항
- 기업 환경에서의 호환성이 중요
- 뉴스 피드, 주식 티커, 라이브 이벤트 스트리밍
- HTTP/S 프로토콜을 그대로 사용해야 하는 환경
- WebRTC 시그널링 서버 (P2P 연결 설정용)

### WebSocket을 선택해야 할 때

- 채팅 앱, 브라우저 게임, 실시간 협업 도구처럼 **지속적인 양방향 통신**이 필요
- 클라이언트→서버 메시지가 빈번한 경우
- 대량의 동시 연결에서 개별 메시지의 지연시간이 매우 중요한 경우

### 피해야 할 것

- **Long-Polling**: 성능 제한이 심각하므로 WebSocket이나 SSE를 지원하지 않는 환경에서의 폴백으로만 사용
- **필요 이상으로 WebSocket 사용**: 단순 요청-응답에 WebSocket을 사용하지 마세요. RESTful API가 더 적합

NodeBB(포럼 소프트웨어)의 사례: 처음에 WebSocket으로 거의 모든 것을 구현했다가, 단순한 요청-응답 작업에는 REST API가 더 나은 솔루션임을 깨닫고 대부분을 마이그레이션했습니다.

---

## 알아두어야 할 함정들

### 재연결 시 이벤트 누락

클라이언트가 연결, 재연결 중이거나 오프라인일 때 서버에서 발생한 이벤트를 놓칠 수 있습니다. 매번 전체 데이터를 스트리밍하는 경우(예: 주식 시세)에는 문제가 없지만, 부분적 결과를 스트리밍하는 경우에는 이를 처리해야 합니다.

해결책으로는 **체크포인트 기반 동기화**가 있습니다. 평소에는 실시간 스트림을 통해 업데이트를 받다가, 연결이 끊어지면 일반 HTTP 요청으로 놓친 데이터를 순차적으로 가져온 후 다시 실시간 모드로 전환하는 방식입니다.

### 기업 방화벽 문제

스트리밍 기술을 사용할 때 기업 인프라에서 다양한 문제가 발생할 수 있습니다. 프록시와 방화벽이 트래픽을 차단하거나 의도치 않게 요청/응답을 손상시킬 수 있습니다. **실제 구현 전에 반드시 해당 기술이 타깃 환경에서 작동하는지 테스트하세요.**

### SSE 타임아웃이 WebSocket보다 더 자주 발생한다?

일부 개발자의 경험에 따르면, SSE 연결이 WebSocket보다 더 자주 타임아웃된다고 합니다. 이미지 스트리밍을 SSE로 구현했는데 계속 데이터를 보내도 타임아웃이 발생했다는 사례가 있습니다.

하지만 이것은 **ISP나 중간 인프라의 정책에 따라 다릅니다.** HTTP에 대한 타임아웃 제한은 보안상의 이유로 여러 레이어에서 설정될 수 있습니다. 35만 명의 사용자를 SSE로 처리한 게임 개발자에 따르면, 99.6%의 성공률을 달성했습니다.

---

## 미래: WebTransport

WebTransport는 HTTP/3(QUIC) 기반의 차세대 기술로, 신뢰성 있는 전송과 비신뢰성 전송을 모두 지원하며 멀티플렉싱과 낮은 지연시간을 제공합니다.

하지만 현재로서는:
- Safari에서 아직 지원되지 않음
- Node.js에서 네이티브 지원 없음
- nginx 등 많은 웹서버에서 HTTP/3가 아직 실험적

WebTransport가 광범위하게 지원될 때까지, SSE와 WebSocket이 실시간 웹 통신의 주력으로 남을 것입니다.

---

## 결론

각 기술은 고유한 장단점이 있으며, 정답은 여러분의 요구사항에 달려 있습니다.

| 요구사항 | 권장 기술 |
|----------|-----------|
| 단방향, 기업 환경 호환성 중시 | **SSE** |
| 양방향, 실시간 상호작용 | **WebSocket** |
| 레거시 환경 폴백 | Long-Polling |

**핵심 조언:**
1. 기술 선택 전에 배포 환경의 제약사항(방화벽, 프록시, 모바일 등)을 반드시 테스트하세요.
2. 어떤 기술을 선택하든 하트비트 메커니즘을 구현하세요.
3. HTTP/2를 사용하면 SSE의 대부분의 제약이 해결됩니다.
4. Socket.IO 같은 라이브러리가 항상 정답은 아닙니다. 때로는 직접 구현이 더 가볍고 효율적입니다.
5. SSE는 생각보다 강력합니다. MMO 게임 백엔드로도 사용될 수 있습니다.

가장 좋은 기술도 여러분의 환경에서 작동하지 않으면 의미가 없습니다. 이론보다 실제 테스트가 중요합니다.


## 참고 문서
- https://rxdb.info/articles/websockets-sse-polling-webrtc-webtransport.html
- https://news.ycombinator.com/item?id=30312897
