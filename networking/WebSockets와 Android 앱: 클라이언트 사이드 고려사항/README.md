# WebSockets와 Android 앱: 클라이언트 사이드 고려사항

## 서론

전 세계적으로 실시간 데이터에 대한 수요가 급증하고 있으며, WebSocket은 이러한 실시간 사용 사례에서 가장 널리 사용되는 전송 프로토콜입니다. WebSocket이 등장하기 전에도 "실시간" 웹은 존재했지만, 구현이 어렵고 속도가 느렸으며, 실시간 애플리케이션용으로 설계되지 않은 기존 웹 기술을 우회하는 방식으로 구현되었습니다. WebSocket 프로토콜은 진정한 실시간 웹으로 가는 길을 열었습니다.

현재 Android SDK는 WebSocket에 대한 네이티브 지원을 제공하지 않습니다. 그러나 Java Development Kit(JDK)에 의존하며, JDK는 `javax.websocket` 패키지의 일부로 WebSocket을 지원합니다. 또한 Kotlin을 Android 앱 개발 언어로 선택했다면, 표준 라이브러리에 포함된 WebSocket 클래스를 활용할 수 있습니다.

이 글에서는 Android를 위한 신뢰할 수 있는 **클라이언트 사이드 WebSocket 솔루션을 구현**할 때 직면하는 다양한 과제들을 살펴보겠습니다.

---

## 현재 상황 개요

기본적인 WebSocket 구현만으로는 잠재적으로 매우 많은 사용자에게 서비스를 제공하는 실시간 앱의 요구사항을 충족하기 어렵습니다. 대부분의 경우 Android 클라이언트 사이드 WebSocket 구현의 기능을 확장하는 것을 고려해야 합니다.

이를 위해 `nv-websocket-client`와 같은 오픈소스 라이브러리를 사용할 수 있습니다. 이 라이브러리는 프록시 지원과 같은 추가 기능을 포함합니다.

### nv-websocket-client를 사용한 WebSocket 인스턴스 생성 예제

```java
// WebSocket 생성. 스킴 부분은 다음 중 하나가 될 수 있습니다:
// 'ws', 'wss', 'http', 'https' (대소문자 구분 없음)
// raw socket 생성에 실패하면 IOException이 발생합니다.
WebSocket ws = new WebSocketFactory().createSocket("ws://localhost/endpoint");
```

### WebSocket 이벤트 리스너 등록

```java
// WebSocket 이벤트를 수신할 리스너 등록
ws.addListener(new WebSocketAdapter() {
    @Override
    public void onTextMessage(WebSocket websocket, String message) throws Exception {
        // 텍스트 메시지 수신
        ......
    }
});
```

### 서버 연결 및 연결 이벤트 모니터링

```java
try {
    // 서버에 연결하고 opening handshake를 수행합니다.
    // 이 메서드는 opening handshake가 완료될 때까지 블로킹됩니다.
    ws.connect();
}
catch (OpeningHandshakeException e) {
    // opening handshake 중 WebSocket 프로토콜 위반이 감지됨
}
catch (HostnameUnverifiedException e) {
    // peer의 인증서가 예상 호스트명과 일치하지 않음
}
catch (WebSocketException e) {
    // WebSocket 연결 설정 실패
}
```

이러한 라이브러리들은 일부 이점을 제공하지만, 본질적으로 WebSocket 클라이언트를 감싸는 래퍼에 불과하며 그 위에 추가 기능을 제공하지 않습니다.

WebSocket을 최대한 활용하려면 그 위에 구축된 프로토콜을 사용하여 pub/sub과 같은 더 풍부한 기능을 활성화하는 것이 좋습니다. 자신의 필요에 맞춘 WebSocket 기반 프로토콜을 직접 개발할 수도 있지만, 이는 매우 복잡하고 시간이 많이 소요되는 작업입니다. 대부분의 경우 전체 엔지니어링 복잡성을 처리할 준비가 된 확립된 WebSocket 기반 솔루션을 사용하는 것이 좋습니다.

---

## Android에서 WebSocket 구현 시 고려해야 할 사항

### 1. WebSocket이 정말 필요한가?

WebSocket은 가장 인기 있고 이식성 있는 실시간 프로토콜입니다. 단일 TCP 연결을 통해 전이중(full-duplex) 통신을 제공합니다. 금융 티커, 채팅 솔루션, 위치 기반 앱 등 많은 사용 사례에 적합합니다. 하지만 유일한 선택지는 아닙니다.

#### 대안 프로토콜들

| 프로토콜 | 특징 | 적합한 사용 사례 |
|---------|------|-----------------|
| **MQTT** | 양방향 통신 지원, 저전력/저대역폭에 최적화 | IoT 디바이스, 불안정한 네트워크 환경, 높은 지연 시간 |
| **SSE (Server-Sent Events)** | 구현과 사용이 간단, 단방향 통신 | 뉴스 피드 구독 등 브라우저 기반 시나리오 |
| **UDP 기반 프로토콜** | 가볍고 빠름, 메시지 전달/순서 보장 없음 | 비디오 스트리밍 |

WebSocket, MQTT, SSE는 모두 TCP 기반 프로토콜입니다. TCP는 신뢰할 수 있는 전송 계층 프로토콜로, 메시지 전달 및 순서 보장을 제공합니다. 하지만 다른 사용 사례에서는 가볍고 빠른 프로토콜이 더 나은 선택일 수 있습니다.

시스템 아키텍처의 복잡성과 목표에 따라 여러 프로토콜을 유연하게 사용하는 것이 좋을 수 있습니다.

---

### 2. 인증 (Authentication)

일반적으로 인증된 사용자만 WebSocket 연결을 사용하도록 허용하는 것이 좋습니다. 그러나 raw WebSocket 요청에는 헤더가 없으므로 HTTP 요청처럼 인증을 제공할 수 없습니다. 따라서 인증을 위한 별도의 컴포넌트나 서비스가 필요합니다.

#### 기본 인증 (Basic Authentication)

가장 간단한 옵션이지만 보안 수준도 가장 낮습니다. API 키를 사용합니다. 자격 증명은 일반적으로 URL의 쿼리 파라미터로 전달됩니다:

```
wss://realtime.example.com/?key=MY_API_KEY&format=json&heartbeats=true&v=1.1
```

**보안 관점의 권장사항:**
- 기본 인증은 서버 사이드에서만 사용하는 것이 좋습니다
- API 키를 여러 클라이언트에 노출하는 것은 매우 안전하지 않습니다
- 임시 API 키를 사용하더라도 키가 만료되면 URL이 작동하지 않습니다
- 요청 로깅 서비스가 서버 로그에 API 키를 캡처할 수 있습니다
- API 키가 갱신될 때마다 새로운 WebSocket 연결을 열어야 하므로 확장성이 없습니다

#### 토큰 기반 인증 (Token-based Authentication)

더 널리 사용되는 인증 메커니즘입니다. 가장 인기 있는 방식 중 하나는 **JSON Web Token (JWT)**입니다. 이는 업계 표준이 된 개방적이고 유연한 형식입니다.

**JWT의 기본 작동 방식:**
1. 클라이언트가 인증 서버에 인증 요청을 보냅니다
2. 인증 서버가 클라이언트에게 액세스 토큰을 반환합니다
3. 클라이언트가 액세스 토큰을 사용하여 보호된 리소스에 접근합니다

**JWT의 장점:**
- 기본 인증보다 더 세분화된 접근 제어 제공
- 노출되거나 손상된 자격 증명의 위험 감소
- 설계상 임시적(ephemeral)이며 취소 가능

**JWT 기반 인증 솔루션 구현 시 고려해야 할 과제:**
- 토큰 권한 및 권한 관리 방법
- TTL(Time To Live) 설정 방법
- 토큰 갱신 방법
- 토큰 전송 방식 (URL을 통해 전송하는 경우, 새 WebSocket 연결 없이 토큰을 갱신할 수 있는 메커니즘 필요)

---

### 3. 네트워크 호환성과 Fallback 전송

WebSocket은 광범위한 플랫폼 지원에도 불구하고 일부 네트워킹 문제를 겪습니다. 주요 문제는 **프록시 통과(proxy traversal)**입니다. 일부 서버와 기업 방화벽이 WebSocket 연결을 차단합니다.

#### 포트 관련 고려사항

- **포트 80, 443**: 웹 액세스를 위한 표준 포트이며 WebSocket을 지원합니다
- **포트 80**: 비보안 연결에 사용됨
- **포트 443**: 보안 연결로, 프록시가 연결을 검사하는 것을 방지하므로 권장됨

다른 포트에서 WebSocket을 실행해야 하는 경우 네트워크 구성이 필요합니다.

#### Fallback 전송 지원의 필요성

포트 443을 사용할 수 없고 클라이언트가 기업 방화벽 내부에서 연결하는 경우, 다음과 같은 fallback 전송을 지원해야 할 수 있습니다:

- XHR 스트리밍
- XHR 폴링
- JSONP 폴링

이를 위해 **SockJS**와 같은 많은 fallback 기능을 제공하도록 설계된 오픈소스 라이브러리를 사용하거나, 직접 복잡한 fallback 기능을 구축할 수 있습니다. 단, 직접 구축해야 하는 경우는 매우 드물며, 엔지니어링 복잡성을 최소화하기 위해 기존의 WebSocket 기반 솔루션을 사용하는 것이 좋습니다.

---

### 4. 디바이스 전원 관리와 Heartbeat

WebSocket 연결은 본질적으로 지속적(persistent)입니다. 이는 활성화되어 있는 동안 배터리를 소모한다는 것을 의미합니다. 디바이스 전원 관리는 필수적으로 고려해야 하지만, 많은 Android WebSocket 라이브러리에서 처리되지 않습니다.

#### Heartbeat 접근 방식

**애플리케이션 레벨 Heartbeat (Ping/Pong)**
- WebSocket 프로토콜은 Ping과 Pong으로 알려진 제어 프레임을 네이티브로 지원합니다
- 일반적으로 서버가 Ping 프레임을 보내고, 클라이언트가 Pong 프레임으로 응답합니다
- WebSocket 연결이 살아있는지 감지할 수 있습니다

**프로토콜 레벨 Heartbeat (TCP Keepalive)**
- 이론적으로 사용 가능하지만 권장되지 않음
- TCP keepalive는 웹 프록시를 통과하지 못함
- 연결을 end-to-end로 항상 검증할 수 없음

#### 배터리 소모와 Push Notification

Heartbeat를 많이 보낼수록 배터리가 빨리 소모됩니다. 특히 모바일 디바이스에서 문제가 될 수 있습니다.

**OS 네이티브 Push Notification의 장점:**
- WebSocket 연결을 활성 상태로 유지할 필요 없음
- 서버가 push notification을 보낼 때마다 비활성 앱 인스턴스를 깨울 수 있음
- 배터리 수명 절약

**Push Notification의 한계:**
- WebSocket이나 스트리밍 프로토콜 계층을 대체할 수 없음
- 서비스 품질 보장을 제공하지 않음
- 일반적으로 임시적(ephemeral)이며 지연 시간이 가변적
- 순서가 보장되지 않음
- 전달 대기열에 넣을 수 있는 알림 수가 제한됨

#### 사용 사례에 따른 선택

| 사용 사례 | 권장 접근 방식 |
|----------|---------------|
| 채팅 솔루션, 멀티플레이어 게임 | 자주 heartbeat 전송 (배터리 소모 감수) |
| 온라인 쇼핑 (신제품 알림) | Push notification (배터리 절약, 정확성은 다소 낮음) |

---

### 5. 연속성을 유지한 재연결 처리

디바이스는 네트워크 조건의 변화를 자주 경험합니다:
- 모바일 데이터에서 Wi-Fi로 전환
- 터널 통과
- 간헐적인 네트워크 문제

이러한 갑작스러운 연결 끊김 시나리오에서는 WebSocket 연결을 재설정해야 합니다.

#### 스트림 재개의 중요성

일부 실시간 사용 사례에서는 중단 후 정확히 중단된 지점에서 스트림을 재개하는 것이 필수적입니다. 예를 들어 라이브 채팅에서 연결 끊김 동안 메시지가 누락되면 혼란과 불만을 야기합니다.

클라이언트 사이드 WebSocket 구현은 재연결 관련 복잡성을 처리하고, 스트림을 재개하며, **정확히 한 번(exactly-once) 전달 보장**을 제공할 수 있어야 합니다.

#### 히스토리/지속 데이터 구현 시 고려사항

짧은 연결 끊김 후 정확히 중단된 지점에서 스트림을 재개하는 것이 중요하다면 **히스토리/지속 데이터**를 구현해야 합니다.

**프론트엔드 메모리에 메시지 캐싱**
- 얼마나 많은 메시지를 저장할 것인가?
- 얼마나 오래 저장할 것인가?

**영구 저장소로 데이터 이동**
- 디스크로 데이터를 이동해야 하는가?
- 얼마나 오래 저장할 것인가?
- 어디에 저장할 것인가?
- 클라이언트가 재연결할 때 해당 데이터에 어떻게 접근할 것인가?

**스트림 재개**
- 클라이언트가 재연결할 때 어떤 스트림을 재개하고 정확히 어디서 재개할지 어떻게 알 수 있는가?
- 연결이 끊긴 위치를 설정하기 위해 연결 ID를 사용해야 하는가?
- 연결 끊김을 추적해야 하는 것은 클라이언트인가, 서버인가?

**백오프 메커니즘**
- 점진적 백오프 전략은 무엇인가?
- 많은 클라이언트가 계속 재연결을 시도(하고 실패)하는 시나리오에서 서버 과부하를 어떻게 방지할 것인가?

#### WebSocket 대신 SSE 고려

양방향 메시징이 필요하지 않고 구독만 필요한 경우, 스트림 재개 기능이 내장된 **SSE (Server-Sent Events)**가 더 나은 선택일 수 있습니다.

---

## 결론

이 글에서 Android를 위한 클라이언트 사이드 WebSocket 기반 솔루션을 구현할 때 예상해야 할 사항들을 살펴보았습니다. Raw WebSocket만으로는 간단한 사용 사례에서도 충분하지 않은 경우가 많습니다.

시스템을 확장하고 최종 사용자에게 최적의 경험을 제공하려면 다음 요소들을 갖춘 WebSocket 솔루션이 필요합니다:

- **적절한 인증 메커니즘** (토큰 기반 인증 권장)
- **네트워크 호환성과 Fallback 지원**
- **효율적인 전원 관리와 Heartbeat 전략**
- **연속성을 유지한 재연결 처리**
- **메시지 전달 및 순서 보장**

사용 사례에 따라 WebSocket이 최선의 선택인지, 아니면 MQTT, SSE 등 다른 프로토콜이 더 적합한지 먼저 평가하는 것이 중요합니다. 또한 필요에 따라 여러 프로토콜을 조합하여 사용하는 유연한 접근 방식을 고려해 보세요.


## 참고 문서
- https://ably.com/topic/websockets-android
