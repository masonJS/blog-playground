## 마이크로 서비스

### 핵심 개념

1. 독립적 배포
   - 다른 서비스를 배포하지 않고, 기능에 대한 배포, 출시가 되어야 함.
   - 서비스간 결합도를 낮춰야 함
2. 비즈니스 도메인을 중심으로 모델링
   - 한 서비스가 기능에 필요한 전체를 구현
   - 한 기능의 구현이 여러 마이크로 서비스에 걸쳐있는 구조를 지양
3. 자신의 상태를 가짐
   - 마이크로 서비스는 DB, 데이터를 공유하지 말아야 한다
   - 다른 서비스의 데이터를 접근해야할때 api를 통해 접근
4. 크기
   - 얼마나 많은 마이크로서비스를 다룰 수 있는가?
     - 조직의 역량
   - 마이크로서비스 경계에 대한 명확한 정의를 할수 있는가?
5. 유연함
   - 아직은 벌어지지 않은 미래를 위해서 고비용을 들어 구축할 필요는 없음.
   - 점진적으로 적용
6. 아키텍처와 조직을 맞춤
   - 조직 구조 -> 아키텍처에 영향을 줌
   - 소프트웨어를 좀더 빨리 배포하기 원함
     - 조직간의 이관이나 사일로를 줄여야 한다
     - 여러 직능을 한 조직으로 모아야 함
     - 프론트, 백엔드 팀 -> 고객팀, 구매팀
   - 비즈니스 도메인 -> 시스템 아키텍처를 주도하는 주요 원동력

### 배포 원칙
- 실행 격리
  - 부하/배포에 있어 마이크로 서비스 간에 영향을 주면 안됨.
  - 격리된 환경에서 마이크로서비스를 실행해야 함.
- 자동화에 초점
  - 마이크로서비스가 증가할수록 복잡도 증가
    - 운영 부하 증가
  - 운영 부하 감소를 위해 자동화에 초점을 맞춰야 함.

### 서비스 간 통신

1. 동기 통신
   - REST (HTTP/JSON)
     - 가장 보편적인 서비스 간 통신 방식
     - 구현이 간단하고 디버깅이 용이
     - 호출자가 응답을 기다려야 하므로 지연 시간에 취약
   - gRPC (HTTP/2, Protocol Buffers)
     - 바이너리 직렬화로 REST 대비 높은 성능
     - 스키마 기반(proto 파일)으로 서비스 간 계약을 명확히 정의
     - 양방향 스트리밍 지원
     - 브라우저에서 직접 호출이 어려워 내부 서비스 간 통신에 적합
2. 비동기 통신
   - 메시지 큐 (RabbitMQ, SQS 등)
     - 생산자와 소비자가 분리되어 느슨한 결합
     - 소비자가 일시적으로 사용 불가해도 메시지가 유실되지 않음
     - Point-to-Point 방식으로 특정 소비자에게 메시지 전달
   - 이벤트 스트리밍 (Kafka 등)
     - Pub/Sub 방식으로 하나의 이벤트를 여러 소비자가 구독 가능
     - 이벤트 로그가 보존되어 재처리 가능
     - 높은 처리량과 확장성
3. 선택 기준
   - 즉각적인 응답이 필요한 경우 → 동기 (REST, gRPC)
   - 서비스 간 결합을 최소화하려는 경우 → 비동기 (메시지 큐, 이벤트)
   - 높은 처리량이 필요한 경우 → 이벤트 스트리밍 (Kafka)
   - 하나의 시스템에서 동기/비동기를 혼합하여 사용하는 것이 일반적

### API Gateway

- 클라이언트와 마이크로서비스 사이의 단일 진입점 역할
- 주요 기능
  - 라우팅: 클라이언트 요청을 적절한 마이크로서비스로 전달
  - 인증/인가: 중앙에서 토큰 검증, 접근 제어를 처리
  - Rate Limiting: 특정 클라이언트의 과도한 요청을 제한
  - 로드 밸런싱: 여러 인스턴스에 트래픽을 분산
  - 응답 집계: 여러 서비스의 응답을 하나로 합쳐서 클라이언트에 반환 (BFF 패턴)
  - 프로토콜 변환: 외부에는 REST, 내부에는 gRPC 등으로 변환
- 주의점
  - Gateway가 단일 장애 지점(SPOF)이 되지 않도록 고가용성 구성 필요
  - Gateway에 비즈니스 로직이 들어가면 안 됨 (라우팅과 횡단 관심사만 처리)

### 서비스 디스커버리

- 마이크로서비스의 위치(IP, 포트)가 동적으로 변하는 환경에서 서비스를 찾는 메커니즘
- Client-Side Discovery
  - 클라이언트가 서비스 레지스트리에 직접 질의하여 인스턴스 목록을 받아 로드밸런싱
  - 예: Netflix Eureka + Ribbon
  - 클라이언트에 디스커버리 로직이 포함되어야 하는 단점
- Server-Side Discovery
  - 로드밸런서가 서비스 레지스트리에 질의하고 요청을 전달
  - 클라이언트는 로드밸런서 주소만 알면 됨
  - 예: AWS ALB, Kubernetes Service
- 서비스 레지스트리
  - 사용 가능한 서비스 인스턴스 목록을 관리하는 데이터베이스
  - 예: Consul, etcd, ZooKeeper
  - 헬스 체크를 통해 비정상 인스턴스를 자동 제거

### 데이터 일관성 / 분산 트랜잭션

- MSA에서는 각 서비스가 독립된 DB를 가지므로, 여러 서비스에 걸친 트랜잭션 처리가 어려움
- 분산 트랜잭션의 한계
  - 2PC (Two-Phase Commit)는 동기적이고 성능 병목이 될 수 있음
  - 서비스 간 강한 결합을 유발하여 MSA의 취지에 맞지 않음
- Saga 패턴
  - 여러 서비스에 걸친 비즈니스 트랜잭션을 로컬 트랜잭션의 연속으로 처리
  - 각 단계 실패 시 보상 트랜잭션(Compensating Transaction)을 실행하여 롤백
  - Choreography 방식
    - 각 서비스가 이벤트를 발행하고 다음 서비스가 이벤트를 구독하여 처리
    - 서비스 간 직접적인 의존이 없어 결합도가 낮음
    - 플로우가 복잡해지면 추적이 어려워짐
  - Orchestration 방식
    - 중앙의 오케스트레이터가 각 서비스를 호출하고 전체 흐름을 관리
    - 흐름이 명확하고 추적이 용이
    - 오케스트레이터에 로직이 집중되는 단점
- Eventual Consistency (최종 일관성)
  - 모든 서비스가 즉시 일관된 상태가 아니더라도, 결국에는 일관된 상태에 도달
  - MSA에서는 강한 일관성(Strong Consistency)보다 최종 일관성을 수용하는 것이 일반적

### 장애 복원력 (Resilience)

- 분산 시스템에서는 네트워크 장애, 서비스 다운 등이 항상 발생할 수 있음
- Circuit Breaker
  - 연쇄 장애(Cascading Failure)를 방지하기 위한 패턴
  - Closed → Open → Half-Open 상태를 전환
    - Closed: 정상 상태, 요청을 그대로 전달
    - Open: 장애 감지 시 요청을 즉시 실패 처리 (빠른 실패)
    - Half-Open: 일정 시간 후 일부 요청을 시도하여 복구 여부 확인
  - 예: Resilience4j, Hystrix (deprecated)
- Retry
  - 일시적인 장애에 대해 재시도
  - 지수 백오프(Exponential Backoff) + 지터(Jitter)를 적용하여 재시도 폭주 방지
  - 멱등성이 보장되는 요청에만 적용해야 함
- Timeout
  - 응답을 무한정 기다리지 않도록 적절한 타임아웃 설정
  - 타임아웃이 없으면 스레드/커넥션 풀이 고갈될 수 있음
- Bulkhead (격벽)
  - 서비스별로 리소스(스레드 풀, 커넥션 풀)를 격리
  - 하나의 서비스 장애가 다른 서비스 호출까지 영향을 주지 않도록 방지
- Fallback
  - 장애 발생 시 대체 응답을 반환
  - 캐시된 데이터 반환, 기본값 반환, 축소된 기능 제공 등

### 관측 가능성 (Observability)

- MSA에서는 요청이 여러 서비스를 거치므로 문제 추적이 어려움
- 세 가지 기둥
  1. 로그 (Logs)
     - 각 서비스에서 발생하는 이벤트를 기록
     - 중앙화된 로그 수집이 필수 (ELK Stack, Loki 등)
     - 서비스 간 요청을 추적하기 위해 Correlation ID를 전파
  2. 메트릭 (Metrics)
     - 서비스의 상태를 수치로 표현 (요청 수, 응답 시간, 에러율 등)
     - 임계치 기반 알림 설정으로 장애 조기 감지
     - 예: Prometheus + Grafana
  3. 분산 추적 (Distributed Tracing)
     - 하나의 요청이 여러 서비스를 거치는 전체 경로를 시각화
     - 병목 구간과 장애 지점을 빠르게 식별
     - 예: OpenTelemetry, Jaeger, Zipkin

### 테스트 전략

- MSA에서는 서비스 간 의존성으로 인해 테스트가 복잡해짐
- 단위 테스트 (Unit Test)
  - 각 서비스 내부 로직을 독립적으로 검증
  - 외부 의존성은 Mock으로 대체
- 통합 테스트 (Integration Test)
  - 서비스 내부에서 DB, 메시지 큐 등 인프라와의 연동을 검증
  - Testcontainers 등을 활용하여 실제 인프라 환경을 구성
- 계약 테스트 (Contract Test)
  - 서비스 간 API 계약이 지켜지는지 검증
  - Consumer-Driven Contract: 소비자가 기대하는 계약을 정의하고, 제공자가 이를 충족하는지 확인
  - 예: Pact
  - 서비스를 독립적으로 배포하면서도 호환성을 보장
- E2E 테스트
  - 전체 시스템을 대상으로 사용자 시나리오를 검증
  - 비용이 높고 느리며 불안정하므로 핵심 플로우에만 최소한으로 적용
- 테스트 피라미드: 단위 > 통합 > 계약 > E2E 순으로 테스트 비중을 가져가는 것이 효과적

### CQRS / Event Sourcing

- CQRS (Command Query Responsibility Segregation)
  - 쓰기(Command)와 읽기(Query)의 모델을 분리
  - 쓰기 모델은 비즈니스 규칙에 최적화, 읽기 모델은 조회 성능에 최적화
  - 읽기/쓰기 부하가 비대칭인 서비스에서 효과적
  - 읽기 모델과 쓰기 모델 간 데이터 동기화가 필요 (보통 이벤트 기반)
- Event Sourcing
  - 상태를 직접 저장하는 대신, 상태 변경 이벤트를 순서대로 저장
  - 현재 상태는 이벤트를 순차적으로 재생(replay)하여 도출
  - 장점
    - 모든 변경 이력이 보존되어 감사(audit)에 유리
    - 이벤트를 재생하여 특정 시점의 상태를 복원 가능
    - 이벤트를 다른 서비스에 발행하여 느슨한 결합 구현
  - 주의점
    - 이벤트 스토어의 크기가 지속적으로 증가 → 스냅샷(Snapshot)으로 최적화
    - 이벤트 스키마 변경 시 하위 호환성을 유지해야 함

### 모놀리스에서 MSA로의 전환

- 빅뱅 전환은 위험이 크므로 점진적 전환을 권장
- Strangler Fig 패턴
  - 기존 모놀리스를 감싸는 형태로 새로운 마이크로서비스를 점진적으로 구축
  - 새로운 기능은 마이크로서비스로, 기존 기능은 점진적으로 이관
  - 프록시 레이어를 통해 트래픽을 기존 시스템과 새 서비스로 분기
- 전환 순서
  1. 도메인 경계를 식별하고 Bounded Context를 정의
  2. 결합도가 낮고 독립성이 높은 도메인부터 분리
  3. 데이터베이스를 분리 (가장 어려운 단계)
  4. API Gateway를 도입하여 점진적으로 라우팅 전환
- 주의점
  - 분리 초기에는 모놀리스와 마이크로서비스가 공존하는 기간이 존재
  - 무리하게 모든 서비스를 분리하려 하지 말고, 비즈니스 가치가 높은 영역부터 시작

### 보안

- 서비스 간 통신 보안
  - mTLS (Mutual TLS): 서비스 간 양방향 인증서 기반 인증 및 암호화
  - Service Mesh (Istio, Linkerd)를 활용하면 애플리케이션 코드 변경 없이 mTLS 적용 가능
- Zero Trust 네트워크
  - 내부 네트워크도 신뢰하지 않는 보안 모델
  - 모든 서비스 간 통신에 인증/인가를 적용
  - 네트워크 위치가 아닌 ID 기반으로 접근 제어
- 인증/인가 전략
  - API Gateway에서 JWT 토큰 검증 후 내부 서비스에 전파
  - 서비스 간에는 내부 토큰 또는 서비스 계정을 사용
  - 민감한 데이터는 서비스별로 암호화 키를 분리 관리

### MSA의 단점과 트레이드오프

- MSA는 만능이 아니며, 모놀리스 대비 다음과 같은 비용이 발생
- 운영 복잡성
  - 서비스 수가 늘어날수록 배포, 모니터링, 디버깅의 복잡도 증가
  - 인프라 관리 부담이 크게 증가 (컨테이너, 오케스트레이션, 서비스 메시 등)
- 네트워크 의존성
  - 서비스 간 통신이 네트워크에 의존하므로 지연 시간과 장애 가능성이 증가
  - 모놀리스에서는 함수 호출이던 것이 네트워크 호출로 바뀜
- 데이터 일관성
  - 분산된 데이터베이스 간의 일관성 유지가 어려움
  - 최종 일관성을 수용해야 하므로 비즈니스 로직이 복잡해질 수 있음
- 테스트 난이도
  - 서비스 간 통합 테스트, E2E 테스트의 구성과 유지가 어려움
- 조직 역량 요구
  - DevOps, 인프라 자동화, 분산 시스템에 대한 이해가 필요
  - 소규모 팀이나 초기 스타트업에서는 오버엔지니어링이 될 수 있음
- 판단 기준
  - 팀의 규모와 역량이 MSA를 감당할 수 있는가?
  - 독립적 배포와 확장이 실제로 필요한가?
  - 모놀리스의 한계에 실제로 부딪혔는가?
  - "모놀리스 우선(Monolith First)" 접근도 유효한 전략
