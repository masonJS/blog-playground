## 선착순 예매 시스템 설계

Redis 및 Kafka 기반 아키텍처 설계

### 핵심 도전 과제

- 한정된 재고를 다수의 사용자가 동시에 확보하려 할 때 발생하는 동시성 문제
- 경쟁 조건(Race Condition)으로 인한 오버부킹, 데이터 불일치
- 10만+ 동시 접속자 처리를 위한 분산 시스템 설계 필요
- 주요 요구사항
  - 빠른 응답성: 예매 시도 시 즉시 성공/실패 결과 반환
  - 확장성: 비즈니스 요구사항 변화에 유연한 대응
  - 안정성: 시스템 장애/정전 시에도 데이터 신뢰성 유지

### 대기열 시스템 (Waiting Queue)

- 선착순 시스템에서 모든 사용자를 동시에 예매 페이지에 진입시키면 서버가 과부하됨
- 대기열을 통해 일정 수의 사용자만 예매 프로세스에 진입하도록 제어

1. Redis Sorted Set 기반 대기열 구현
   - `ZADD queue:{event_id} {timestamp} {user_id}`로 대기열에 진입
     - score를 타임스탬프로 사용하여 자동 정렬 (선착순 보장)
   - `ZRANK queue:{event_id} {user_id}`로 현재 대기 순번 조회
   - `ZRANGE queue:{event_id} 0 {N-1}`로 상위 N명을 진입 허용 대상으로 추출
   - `ZREM queue:{event_id} {user_id}`로 진입 허용된 사용자를 대기열에서 제거
2. 진입 허용 메커니즘
   - 스케줄러가 주기적으로(예: 1초마다) 대기열에서 N명씩 진입 허용
   - 진입 허용된 사용자를 별도의 Set에 등록: `SADD active:{event_id} {user_id}`
   - 예매 API 호출 시 `SISMEMBER active:{event_id} {user_id}`로 진입 허용 여부 검증
   - 진입 허용 수(N)는 서버 처리 용량에 따라 동적으로 조절 가능
3. 대기열 상태 알림
   - 폴링 방식: 클라이언트가 주기적으로 대기 순번 API를 호출
     - 구현이 간단하지만 불필요한 요청이 발생
   - SSE (Server-Sent Events): 서버에서 클라이언트로 단방향 이벤트 푸시
     - 대기 순번 변경, 진입 허용 시점을 실시간 알림
     - WebSocket보다 구현이 간단하고 HTTP 기반이라 인프라 호환성이 높음
   - WebSocket: 양방향 통신이 필요한 경우 (채팅 등 추가 기능 포함 시)

### 좌석 임시 확보 (TTL 기반 잠금)

- 사용자가 좌석을 선택한 후 결제를 완료할 때까지의 임시 잠금 메커니즘
- 결제 완료 전 이탈/타임아웃 시 다른 사용자에게 기회를 제공해야 함

1. 임시 잠금 구현
   - `SET seat:{event_id}:{seat_id} {user_id} NX PX {timeout_ms}`
     - 좌석 선택 시 해당 좌석을 TTL과 함께 잠금
     - `NX`: 이미 잠긴 좌석은 선택 불가
     - `PX`: 예를 들어 300000ms (5분) 후 자동 만료
   - 결제 완료 시 잠금을 영구 확정 상태로 전환 (별도 키 또는 DB 저장)
   - 결제 미완료 시 TTL 만료로 자동 해제 → 재고 원복
2. 상태 전이
   - `AVAILABLE` → `HELD` (임시 확보, TTL 설정)
   - `HELD` → `CONFIRMED` (결제 완료, 영구 확정)
   - `HELD` → `AVAILABLE` (TTL 만료 또는 사용자 취소, 자동 해제)
3. 주의점
   - TTL이 너무 짧으면 결제 중 잠금이 풀려 다른 사용자에게 넘어갈 수 있음
   - TTL이 너무 길면 이탈한 사용자의 좌석이 오래 잠겨 다른 사용자가 불이익
   - 결제 진행 중 TTL 연장(갱신) 로직 고려 필요
   - TTL 만료 시 Redis Keyspace Notification 또는 스케줄러로 재고 원복 처리

### 트래픽 제어 / Rate Limiting

1. API Gateway 단 제어
   - Token Bucket
     - 일정 속도로 토큰이 충전되고, 요청 시 토큰을 소비
     - 버스트 트래픽을 일정 수준까지 허용하면서 전체 처리율을 제한
   - Sliding Window
     - 시간 윈도우 내의 요청 수를 카운팅하여 초과 시 거부
     - Redis `ZRANGEBYSCORE`로 구현 가능
   - 사용자별, IP별, 전체 요청별로 각각 다른 제한을 적용
2. 봇/매크로 방어
   - CAPTCHA: 예매 시작 전 또는 의심스러운 패턴 감지 시 적용
   - 요청 패턴 분석: 비정상적으로 빠른 반복 요청, 동일 헤더 패턴 감지
   - Device Fingerprinting: 브라우저/기기 고유 정보로 동일 사용자의 다중 접속 탐지
   - Redis에 차단 목록 관리: `SET blocked:{ip} 1 EX 3600`

### 재고 카운팅 및 확인 (Redis)

1. 원자적 연산을 활용한 재고 관리
   - `INCR`, `DECR`, `INCRBY`, `DECRBY`로 재고를 원자적으로 증감
   - 여러 클라이언트가 동시 요청해도 경쟁 조건 없이 원자성 보장
   - 재고 키 설계: `event:{item_id}:stock`
   - `DECR` 결과가 음수이면 재고 부족으로 판단하여 예매 실패 처리
2. 분산 락을 이용한 동시성 제어
   - `SET key value NX PX milliseconds`로 분산 락 구현
     - `NX`: 키가 존재하지 않을 때만 설정 (상호 배타성 보장)
     - `PX`: 만료 시간 설정 (데드락 방지)
   - Redlock 알고리즘
     - 과반수(N/2 + 1) 이상의 인스턴스에서 락 획득 시 성공
     - 단일 장애점(SPOF) 방지, 결함 허용(Fault Tolerance) 확보
   - 단순 `DECR`만으로는 복합 비즈니스 로직의 원자성 보장 불가
     - 재고 확인 → 중복 확인 → 재고 감소 → 예매 저장 전체를 락으로 보호
   - Redisson의 `RLock`: Lua 스크립트로 분산 락을 간편하게 구현
3. 데이터 영속성 확보
   - Redis는 인메모리 DB이므로 서버 종료 시 데이터 유실 가능
   - RDB: 특정 시점의 스냅샷 저장
   - AOF: 모든 쓰기 연산을 로그로 기록
     - `fsync` 옵션으로 동기화 빈도 조절 (성능 ↔ 안정성 트레이드오프)
     - 서버 재시작 시 락 상태 및 재고 데이터 복원 가능

### 유저별 중복 예매 방지 (Redis)

1. 멱등성(Idempotency)
   - 동일한 요청이 여러 번 도달해도 최초 한 번의 결과와 동일하게 유지
   - 네트워크 지연, 재시도 등으로 인한 중복 요청 방어
2. `SET NX`를 활용한 중복 방지
   - 고유 멱등키 생성 후 `SET NX`로 Redis에 저장
   - 성공(true): 첫 요청 → 예매 로직 진행
   - 실패(false): 중복 요청 → 예외 반환
   - `EX`/`PX` 옵션으로 만료 시간 설정하여 메모리 최적화
3. 멱등키 설계
   - 형식: `reservation:{user_id}:{event_id}:{seat_id}` 또는 고유 UUID
   - 저장 시점: 비즈니스 로직 검증이 통과된 후, 상태 변경 직전
     - 검증 실패할 요청에 대해 불필요하게 멱등키가 저장되는 것을 방지
   - Set 자료구조 대신 단순 Key-Value 형태의 `SET NX` 사용

| 기능 | Redis 명령어/기법 | 설명 |
|------|-------------------|------|
| 재고 카운팅 | `INCR`, `DECR` | 원자적 증감으로 경쟁 조건 방지 |
| 재고 감소 원자성 | Redlock, `SET NX PX` | 복합 비즈니스 로직 전체에 대한 상호 배타적 접근 보장 |
| 중복 예매 방지 | 멱등키 `SET NX` | 동일 요청의 중복 처리 방지, 만료 시간으로 메모리 효율화 |

### 대규모 트래픽 처리 및 비동기 처리 (Kafka)

1. Kafka의 역할
   - 순간 급증하는 예매 요청을 안정적으로 수용
   - 시스템 간 결합도를 낮추어 유연성/유지보수성 향상
   - 'At Least Once' 보장으로 메시지 유실 방지
   - 메시지 보존 정책으로 데이터 손실 시 재요청 가능
2. Producer → Topic → Partition → Consumer 설계
   - Producer (웹/API 서버)
     - 예매 정보를 Kafka Topic에 메시지로 발행
     - `partition_key`로 동일 키의 메시지를 같은 파티션에 저장 (순서 보장)
     - `batch.size`, `linger.ms` 설정으로 네트워크 오버헤드 최소화
   - Topic / Partition
     - 파티션은 여러 Broker에 분산 저장 (내결함성)
     - 파티션 수 ↑ = 처리량 ↑
     - 파티션 수와 Consumer 수를 1:1로 맞추는 것이 효율적
   - Consumer Group
     - Pull 방식으로 처리 가능한 속도로 메시지 소비
     - offset 추적으로 장애 후 중단 지점부터 재처리
     - `RetryTemplate` 등으로 재처리 로직 구현
3. Partition Key 전략
   - 순서 보장이 필요한 경우에만 `partition_key` 사용
   - 특정 키에 트래픽 집중 시 파티션 불균형(imbalance) 발생 가능
   - 순서 보장이 불필요한 경우 라운드 로빈 방식(key = null)으로 부하 분산
4. 이벤트 소싱 패턴
   - 모든 이벤트(예매 요청, 재고 감소, 결제 등)를 Kafka에 기록
   - 이벤트 재실행으로 현재 상태 재구성 또는 감사(audit) 활용
   - CQRS와 결합하여 읽기/쓰기 작업 분리 → 성능, 확장성 극대화
5. 'At Least Once'와 멱등성
   - 메시지 중복 전달 가능성 존재
   - Consumer 측에서 멱등성을 반드시 확보해야 함
   - Redis `SET NX` 기반 멱등성 구현과 직접 연결

### Redis와 Kafka 통합 아키텍처

1. 역할 분담
   - Redis: 즉각적 응답 + 높은 일관성이 필요한 임계 영역
     - 실시간 재고 카운팅, 분산 락, 중복 예매 방지
   - Kafka: 높은 처리량 + 느슨한 결합이 필요한 비동기 후처리
     - 예매 확정, 결제, 알림, 통계 등
   - Redis가 유효하지 않은 요청을 빠르게 필터링 → Kafka로 전달되는 메시지 수 감소
2. 예매 요청 처리 파이프라인
   - 사용자 요청 → API Gateway/Load Balancer → 웹/API 서버
   - 웹/API 서버 (Producer)
     1. 진입 허용 확인: Redis `SISMEMBER active:{event_id} {user_id}`로 대기열 통과 여부 확인
     2. 중복 요청 방지: Redis `SET NX`로 멱등키 확인 → 중복 시 즉시 실패
     3. 분산 락 획득: Redis Redlock으로 동시성 제어
     4. 재고 확인/감소: Redis `DECR`로 재고 감소 → 음수면 실패 처리 후 락 해제
     5. 좌석 임시 확보: Redis `SET NX PX`로 좌석 잠금 (TTL 설정)
     6. Kafka 메시지 발행: 예매 요청 정보를 '예매 요청' Topic에 발행
     7. 락 해제 및 즉시 응답: "예매 요청 접수 완료" 반환
   - Kafka Broker: 메시지를 파티션에 저장
   - 예매 처리 서비스 (Consumer)
     1. 멱등성 재확인: Kafka 'At Least Once'로 인한 중복 방지
     2. DB 저장: RDBMS에 예매 정보 최종 저장 (ACID 보장)
     3. 결제 처리 연동
     4. 좌석 상태 확정: 임시 확보 → 영구 확정으로 전환
     5. 결과 메시지 발행: '예매 확정' 또는 '예매 실패' Topic으로 발행
   - 후처리 서비스 (Consumer)
     - 예매 확정 → 알림 발송, 통계 업데이트, CRM 연동
     - 예매 실패 → 실패 알림, 재고 원복
3. 데이터 일관성 유지 전략
   - 선처리(Redis)와 후처리(Kafka)의 책임 분리
   - Redis `INCR`/`DECR` + 분산 락으로 원자성 보장
   - Redis `SET NX` + Kafka Consumer 멱등성으로 중복 방지
   - Redis RDB/AOF + Kafka 디스크 영속화로 데이터 유실 방지
   - RDBMS 트랜잭션으로 최종 데이터 일관성 유지

### 실패 시나리오별 보상 처리

- Redis와 DB 사이에 비동기 구간이 존재하므로 데이터 불일치가 발생할 수 있음

1. Redis 재고 감소 성공 → Kafka 발행 실패
   - 원인: Kafka 브로커 장애, 네트워크 단절
   - 보상: Redis `INCR`로 재고 원복, 멱등키 삭제
   - 전체 흐름을 try-catch로 감싸고, Kafka 발행 실패 시 즉시 롤백
2. Kafka 발행 성공 → Consumer DB 저장 실패
   - 원인: RDBMS 장애, 제약 조건 위반
   - 보상: Dead Letter Queue(DLQ)로 실패 메시지 이동
   - DLQ 메시지를 별도 프로세스에서 재처리하거나 수동 확인
   - 재처리 횟수 초과 시 Redis 재고 원복 및 관리자 알림
3. 결제 실패
   - 보상: 좌석 잠금 해제 (`DEL seat:{event_id}:{seat_id}`), 재고 원복 (`INCR`)
   - '예매 실패' Topic으로 이벤트 발행하여 후처리 서비스가 알림 발송
4. Redis 장애 (전체 다운)
   - 보상: Redis Sentinel/Cluster 자동 페일오버로 슬레이브 승격
   - 페일오버 동안의 유실 데이터는 AOF 로그 기반 복원
   - 최종적으로 RDBMS 데이터를 기준으로 Redis 재고를 재동기화
5. 일관성 검증
   - 주기적 정합성 체크: Redis 재고와 RDBMS 예매 건수의 합이 초기 재고와 일치하는지 검증
   - 불일치 발견 시 RDBMS를 기준(Source of Truth)으로 Redis를 보정
   - 감사 로그: 모든 재고 변경 이벤트를 Kafka에 기록하여 추적 가능

### 캐시 워밍업 (Cache Warming)

- 이벤트 오픈 시점에 Redis에 데이터가 없으면 대량의 요청이 DB로 몰림 (Cache Stampede)

1. 사전 로딩 전략
   - 이벤트 오픈 전 스케줄러 또는 관리자 API를 통해 Redis에 데이터 미리 적재
     - 재고 수: `SET event:{item_id}:stock {total_count}`
     - 좌석 정보: 좌석 목록, 가격 등 조회 빈도가 높은 데이터
   - DB에서 조회하여 Redis에 적재하는 배치 작업
2. 워밍업 대상
   - 이벤트 기본 정보 (이름, 일시, 장소)
   - 재고 수량
   - 좌석 배치도 및 가격 정보
   - Rate Limiting 설정값
3. 워밍업 검증
   - 워밍업 완료 후 Redis 키 존재 여부 및 값 정합성 확인
   - 워밍업 실패 시 이벤트 오픈을 지연하거나 관리자에게 알림
   - 헬스 체크에 Redis 워밍업 상태를 포함

### DB 병목 해결

- Kafka Consumer가 RDBMS에 최종 저장할 때 대량의 쓰기가 집중될 수 있음

1. Batch Insert
   - Consumer가 메시지를 건별로 처리하지 않고, 일정 수/시간 단위로 모아서 일괄 저장
   - JDBC `addBatch()` + `executeBatch()`로 네트워크 왕복 횟수 감소
   - 배치 크기가 너무 크면 트랜잭션 유지 시간이 길어지므로 적절한 크기 조절 필요
2. Connection Pool 튜닝
   - HikariCP 등의 커넥션 풀 크기를 Consumer 스레드 수에 맞게 설정
   - `maximumPoolSize`: 동시 DB 접근 스레드 수 + 여유분
   - `connectionTimeout`: 커넥션 획득 대기 시간 설정으로 대기 스레드 누적 방지
3. Write 분산
   - DB Replication: 읽기는 Replica, 쓰기는 Primary로 분리
   - 샤딩(Sharding): 이벤트 ID 기반으로 예매 데이터를 여러 DB에 분산 저장
   - 파티셔닝: 테이블을 이벤트 ID 또는 날짜 기준으로 파티셔닝하여 쓰기 성능 향상
4. 인덱스 최적화
   - 예매 저장 시 불필요한 인덱스가 쓰기 성능을 저하시킬 수 있음
   - 이벤트 진행 중에는 최소한의 인덱스만 유지하고, 종료 후 인덱스를 추가하는 전략

### 클라이언트 측 방어

1. 중복 클릭 방지
   - 예매 버튼 클릭 후 즉시 비활성화 (Debounce/Throttle)
   - 응답을 받기 전까지 로딩 상태 표시
   - 서버 응답과 무관하게 클라이언트 단에서 1차 방어
2. 결과 수신 방식
   - 예매 요청은 비동기이므로 결과를 별도로 수신해야 함
   - 폴링: 주기적으로 예매 상태 API를 호출하여 결과 확인
     - 구현이 간단하지만 불필요한 요청 발생, 실시간성이 낮음
   - SSE (Server-Sent Events): 서버에서 예매 결과를 푸시
     - 단방향 통신으로 충분하며, HTTP 기반이라 프록시/로드밸런서 호환성이 좋음
   - WebSocket: 양방향 통신이 필요한 경우
     - 커넥션 유지 비용이 높으므로, 대규모 동시 접속 시 서버 리소스 고려 필요
3. 예매 대기 UX
   - 대기열 순번, 예상 대기 시간을 실시간으로 표시
   - 진입 허용 시 자동으로 예매 페이지로 전환
   - 브라우저 탭 비활성화/새로고침 시에도 대기열 유지 (세션/토큰 기반)
   - 대기 중 이탈 시 대기열에서 자동 제거 (하트비트 방식)

### 시스템 확장성 및 안정성

1. 장애 허용 및 복구
   - Redis
     - RDB/AOF로 재시작 시 데이터 복원
     - Redis Sentinel 또는 Cluster로 마스터-슬레이브 복제 및 자동 페일오버
     - Redlock으로 단일 인스턴스 장애 시에도 락 배타성 유지
   - Kafka
     - 데이터를 여러 브로커에 복제하여 고가용성 확보
     - 파티션 리더/팔로워로 브로커 장애 시에도 처리 지속
     - Consumer offset 관리로 장애 후 중단 지점부터 재처리
     - ZooKeeper로 클러스터 관리 및 노드 간 상태 동기화
   - 전체 시스템
     - 타임아웃/롤백으로 데드락 방지 및 자원 해제
     - 서킷 브레이커 패턴으로 외부 시스템 장애의 전파 방지
     - 재시도 메커니즘(`RetryTemplate`)으로 일시적 장애 복원력 확보
2. 스케일 아웃 전략
   - API 서버
     - Stateless 설계로 인스턴스를 자유롭게 추가/제거
     - Load Balancer로 트래픽 분산 (Round Robin, Least Connection 등)
     - Auto Scaling: 트래픽 급증 시 자동으로 인스턴스 확장 (CPU/메모리/요청 수 기반)
   - Redis
     - Redis Cluster: 데이터를 여러 노드에 샤딩하여 읽기/쓰기 분산
     - 16384개의 해시 슬롯을 노드에 분배
     - 노드 추가 시 해시 슬롯 재배분으로 수평 확장
   - Kafka
     - 파티션 수 증가로 병렬 처리량 확장
     - 브로커 추가로 저장 용량 및 처리량 확장
     - Consumer 수를 파티션 수에 맞춰 동적으로 확장
   - DB
     - Read Replica 추가로 조회 부하 분산
     - 이벤트 단위 샤딩으로 쓰기 부하 분산
3. 모니터링 및 운영
   - 메트릭 수집: Redis(메모리, 연결 수, 처리량), Kafka(처리량, 지연, 파티션 상태), App(JVM, 응답 시간, 에러율)
   - 로그 관리: 중앙 집중식 로깅 (ELK Stack, Splunk)
   - 알림 시스템: 임계치 초과, 에러, 시스템 다운 시 즉시 알림
   - 대시보드: Grafana, Prometheus로 실시간 모니터링
4. 부하 테스트
   - 도구: k6, nGrinder, JMeter, Gatling 등
   - 시나리오 설계
     - 점진적 부하 증가: 1000 → 5000 → 10000 → ... 동시 사용자 증가
     - 스파이크 테스트: 이벤트 오픈 시점을 시뮬레이션하여 순간 급증 트래픽 테스트
     - 지속 부하 테스트: 일정 수준의 트래픽을 장시간 유지하여 메모리 누수, 커넥션 고갈 확인
   - 측정 지표
     - 응답 시간 (p50, p95, p99)
     - 처리량 (TPS, RPS)
     - 에러율
     - Redis 메모리 사용량, Kafka Consumer Lag
   - 병목 지점 식별 후 개선 → 재테스트 반복
5. 성능 최적화
   - Redis
     - 파이프라인/트랜잭션으로 RTT 감소
     - 목적에 맞는 데이터 구조 선택 (String, Hash, Set, Sorted Set 등)
     - `maxmemory` 설정 및 eviction 정책으로 메모리 관리
   - Kafka
     - 배치 전송으로 네트워크 효율성 향상
     - 메시지 압축으로 대역폭/디스크 I/O 최적화
     - 적절한 파티션 수 설정으로 병렬 처리 최적화
     - Consumer 수를 파티션 수에 맞춰 확장
   - 애플리케이션
     - 논블로킹 I/O, 스레드 풀 관리로 동시성 처리 향상
     - 애플리케이션 레벨 캐시(Caffeine 등)로 DB 부하 감소

### 향후 개선 방향

- CQRS 심화 적용: 읽기 전용 Materialized View + 별도 읽기 DB로 조회 성능 최적화
- Saga 패턴: 예매-결제-알림 간 분산 트랜잭션 일관성 보장
- 서버리스 아키텍처: AWS Lambda 등과 연동하여 운영 오버헤드 감소
- AI/ML 수요 예측: 과거 데이터 기반 수요 예측으로 자원 할당 효율화
- 보안 강화: 인증/인가, 데이터 암호화, 정기적 보안 감사
