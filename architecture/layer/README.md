# 아키텍처

### 계층형 아키텍처

- 전통적인 계층 구조: Presentation(Controller) → Business(Service) → Persistence(Repository)
- 각 계층은 자신의 관심사에만 집중하고, 같은 계층이나 바로 아래 계층에만 접근 가능
- 가장 널리 사용되는 아키텍처 패턴이며 이해하기 쉽고 직관적

### 계층형 아키텍처의 문제점
- 지름길을 택하기 쉬워진다.
 	- 전통적인 계층형 아키텍처에서 적용되는 규칙은 특정 계층에서의 접근은 같은 계층에 있는 컴포넌트나 바로 아래의 계층에만 접근가능하다.
 	- 이 말뜻은 만약 상위 계층에 위치한 컴포넌트에 접근해야 한다면 간단하게 컴포넌트를 계층 아래로 내려버리면 된다.
 	- 아무렇지 않게 생각했던 것들이 관심사 분리의 원칙을 지키지 못하고 변경하기 어려운 아키텍처를 만드는 지름길을 가게 한다.

- 서비스 계층의 너비 확장 (Fat Service & Anemic Domain Model)
	- 계층형 아키텍처는 도메인 서비스의 '너비'에 대해 규칙으로써 강제하지 않는다.
- 시스템의 복잡도가 올라갈수록 서비스에 많은 영속성 계층의 의존성을 가지게 되 넓은 서비스를 이루게 된다.

- 데이터베이스 주도 설계를 유도
	- 의존성 방향이 영속성 계층을 향하므로, 자연스럽게 데이터베이스 중심으로 설계하게 됨
	- 도메인 로직보다 엔티티(테이블 매핑 객체)를 먼저 만들고, 그 위에 서비스를 쌓는 구조가 됨
	- 비즈니스 관점이 아닌 데이터 저장 관점에서 아키텍처가 결정됨
<br><br>

### 단일 책임 원칙
하나의 컴포넌트는 오로지 한가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.
위와 같이 정의되는 내용이 일반적이지만 사실 실제 의도를 내포하고 있지않다.
오로지 한가지 일만 해야 하고는 가장 직관적인 해석에 불가하며 실제 정의는 다음과 같다.

> 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.

단일 책임 원칙에서 '책임'은 한 가지 일이 아닌 변경할 이유라고 해석 되어야 한다.
변경할 이유가 한 가지라는 것은 우리는 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다.
<br><br>

### 의존성 역전 원칙 (DIP)
> 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안 된다. 둘 다 추상화에 의존해야 한다.

- 전통적인 계층형 아키텍처에서는 상위 계층(Service)이 하위 계층(Repository 구현체)에 직접 의존
- DIP를 적용하면 의존성의 방향을 역전시킬 수 있음
  - Service가 Repository 인터페이스(추상화)에 의존
  - Repository 구현체도 Repository 인터페이스(추상화)에 의존
  - 결과적으로 도메인/비즈니스 계층이 인프라 계층에 의존하지 않게 됨
- 이를 통해 도메인 로직이 인프라(DB, 외부 API 등)의 변경으로부터 보호됨
- 헥사고날 아키텍처, 클린 아키텍처의 핵심 원리
<br><br>

### 비즈니스 규칙 검증 vs 입력 유효성 검증
비즈니스 규칙 검증
- 검증을 위해 도메인 모델의 현재 상태에 접근해야 한다.
- 서비스의 비즈니스 규칙의 맥락(semantical)에 대한 유효성 검증
- service에서 처리

입력 유효성 검증
- 검증을 위해 도메인 모델의 현재 상태에 접근할 필요가 없다.
- 구문상(syntactical)의 유효성 검증
- controller 에서 처리
<br><br>

### 계층형 패키징 vs 기능형 패키징
계층형 패키징
- 어플리케이션의 기능및 특성을 구분짓는 패키지 경계가 없다.
- 어플리케이션이 어떤 유스케이스를 제공하는지 알수 없다.

기능형 패키징
- 관련된 기능을 하나의 패키지에 모아 높은 응집도를 가짐
- 기능 변경 시 영향 범위가 해당 패키지 내로 한정되어 변경 비용이 낮음
- 패키지 이름만으로 어플리케이션이 어떤 기능을 제공하는지 파악 가능
- 아키텍처의 가시성을 떨어뜨린다는 단점이 있음 (계층 구조가 드러나지 않음)
- [Java Practices -> Package by feature, not layer](http://www.javapractices.com/topic/TopicAction.do?Id=205)
<br><br>

### 풍부한 도메인 모델 vs 빈약한 도메인 모델
풍부한 도메인 모델
- 서비스에서는 사용자의 의도만 표현하면서 이 의도의 실제 수행작업은 도메인에서 처리
- 비즈니스 규칙이 도메인 모델에 위치

빈약한 도메인 모델 (Anemic Domain Model)
- 비즈니스 규칙이 서비스에 위치
- [빈약한 도메인 모델](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=muchine98&logNo=220304821784)
<br><br>

### SDP (안정된 의존성 원칙)
> 의존은 안정적인 쪽으로 향해야 한다.

소프트웨어 설계는 정적일수 없고 끊임없는 변화에 대한 수용이 필연적일수 밖에 없다.
이러한 변화에 대해서 SDP 원칙은 변경이 어려운(안정적인) 모듈이 변경이 큰(불안정적인) 모듈에게 의존하지  않도록 한다.

안정성에 대한 의미
- 안정성이란 "변경이 쉽지 않다."라는 의미로 소프트웨어에서의 안정성은 해당 모듈에 의존하는 모듈들이 많으면 많을수록 안전해진다. (해당 모듈의 변경이 의존하고있는 N개의 모듈에 영향을 주기 때문에)
- "안정성"이라는 단어의 뜻이 긍정의 느낌을 주지만 소프트웨어상에선 "안정적이다"라는 의미는 변경하기 어렵다, 변경을 하기에 많은 리소스가 필요하다.
- 변경이 일어나면 많은 사이드 이펙트를 발생한다에 의미를 내포하고 있다.

안정성의 측정
- 불안정성 = 현재 모듈이 의존하고 있는 내부 모듈의 수(Fan-out) / (현재 모듈에 의존하는 외부 모듈의 수 (Fan-in)  + 현재 모듈이 의존하고 있는 내부 모듈의 수(Fan-out))
- 예를 들어 SampleService 가 4개의 객체에 의존하고 있고 1개의 객체(SampleController)에 의존당하고 있다면 4 / (1 + 4) = 4 / 5 = 0.8 의 불안정성을 가진다.

불안정성의 범위
- 최대값인 1은 변경가능성이 높은 모듈
- 최소값인 0은 변경가능성이 낮은 모듈
<br><br>

### SAP (안정된 추상화 원칙)
> 모듈은 안정적인 만큼 추상화되어야 한다.

C,S,R 측면에서의 추상성과 안정성 관계
- Controller => (1, 0) (불안정, 구체적)
- Repository => (0, 1) (안정적, 추상적)
- Service
  - 인프라 서비스 => (0, 1) (안정적, 추상적)
  - 비즈니스 서비스 => 상황에 맞게
<br><br>

### 헥사고날 아키텍처 (Ports & Adapters)

- 계층형 아키텍처의 문제점을 해결하기 위한 대안 아키텍처
- 핵심 원리: 비즈니스 로직(도메인)이 중심에 위치하고, 외부 세계와의 통신은 포트와 어댑터를 통해 이루어짐

구조
- 도메인 (중심)
  - 비즈니스 로직과 도메인 모델이 위치
  - 어떠한 외부 의존성도 갖지 않음
- Inbound Port (입력 포트)
  - 외부에서 도메인으로 들어오는 요청을 정의하는 인터페이스
  - 유스케이스를 표현 (예: SendMoneyUseCase)
- Inbound Adapter (입력 어댑터)
  - 입력 포트를 호출하는 외부 구현체
  - 예: REST Controller, gRPC Handler, CLI, Message Consumer
- Outbound Port (출력 포트)
  - 도메인에서 외부로 나가는 요청을 정의하는 인터페이스
  - 예: LoadAccountPort, UpdateAccountStatePort
- Outbound Adapter (출력 어댑터)
  - 출력 포트를 구현하는 외부 구현체
  - 예: JPA Repository, REST Client, Message Publisher

장점
- 도메인 로직이 외부 인프라에 의존하지 않아 테스트가 용이
- 어댑터 교체만으로 인프라 기술을 변경할 수 있음 (예: JPA → MyBatis)
- 의존성 방향이 항상 도메인을 향하므로 비즈니스 로직 보호
<br><br>

### 클린 아키텍처

- Robert C. Martin(Uncle Bob)이 제안한 아키텍처
- 핵심 규칙: 의존성은 항상 바깥에서 안쪽으로만 향해야 한다 (Dependency Rule)

계층 구조 (안쪽 → 바깥쪽)
1. Entity (엔티티)
   - 핵심 비즈니스 규칙을 캡슐화
   - 가장 변경 가능성이 낮은 계층
2. Use Case (유스케이스)
   - 애플리케이션 고유의 비즈니스 규칙
   - 엔티티로의 데이터 흐름을 조정
   - 예: 송금하기, 주문 취소하기
3. Interface Adapter (인터페이스 어댑터)
   - 유스케이스와 외부 세계 사이의 데이터 변환
   - Controller, Presenter, Gateway 등이 위치
4. Framework & Driver (프레임워크와 드라이버)
   - 가장 바깥쪽 계층
   - DB, 웹 프레임워크, UI 등 세부 구현 사항
   - 가장 변경 가능성이 높은 계층

헥사고날 아키텍처와의 관계
- 클린 아키텍처는 헥사고날 아키텍처의 사상을 포함하는 상위 개념
- 헥사고날의 Inbound/Outbound Port는 클린 아키텍처의 Interface Adapter 경계에 해당
- 둘 다 "도메인이 중심이고 인프라가 도메인에 의존한다"는 동일한 원칙을 공유
<br><br>

### 계층 간 매핑 전략

- 계층 사이에서 데이터를 전달할 때 어떤 모델을 사용할 것인가에 대한 전략

No Mapping (매핑 없음)
- 모든 계층에서 동일한 모델(예: 도메인 엔티티)을 사용
- 구현이 간단하지만, 계층 간 결합도가 높아짐
- 단순한 CRUD 서비스에 적합

Two-Way Mapping (양방향 매핑)
- 각 계층이 자신만의 모델을 가지고, 계층 경계에서 양방향으로 변환
- 예: Controller는 DTO, Service는 Domain Model, Repository는 Entity 사용
- 매핑 코드가 많아지지만 계층 간 독립성이 높음

Full Mapping (전체 매핑)
- 각 연산마다 별도의 입출력 모델을 정의
- 예: SendMoneyCommand, SendMoneyResult 등 유스케이스별 전용 객체
- 가장 엄격하지만 유스케이스의 의도가 명확해짐

One-Way Mapping (단방향 매핑)
- 모든 계층의 모델이 동일한 인터페이스를 구현하되, 해당 인터페이스는 읽기 전용
- 상태를 변경하려면 해당 계층의 모델로 매핑해야 함
- DDD의 도메인 모델 접근 방식과 잘 어울림

선택 기준
- 변경이 잦고 복잡한 영역 → Full Mapping 또는 Two-Way Mapping
- 단순하고 변경이 적은 영역 → No Mapping
- 하나의 프로젝트에서 영역별로 다른 전략을 혼합하여 사용하는 것이 현실적
<br><br>

### 아키텍처와 테스트 용이성

- 아키텍처 구조가 테스트 작성의 용이성을 결정함
- 의존성 역전이 적용된 아키텍처의 테스트 장점
  - 도메인 로직을 외부 의존성 없이 순수 단위 테스트로 검증 가능
  - 포트(인터페이스) 기반이므로 Mock 객체 생성이 용이
  - 인프라(DB, 외부 API) 없이도 빠르게 테스트 실행 가능
- 계층형 아키텍처에서의 테스트 문제
  - 서비스가 Repository 구현체에 직접 의존하면 DB 없이 테스트가 어려움
  - 서비스 계층이 비대해지면 테스트 설정(setup)이 복잡해짐
- 테스트 전략 예시
  - 도메인 모델: 순수 단위 테스트 (의존성 없음)
  - 유스케이스(서비스): Outbound Port를 Mock하여 단위 테스트
  - 어댑터: 통합 테스트 (실제 인프라 연동 검증, Testcontainers 등)
  - 시스템: 전체 흐름 검증을 위한 E2E 테스트 (최소한으로 유지)
<br><br>

### 경계 간 데이터 전달 객체

- 계층 경계를 넘을 때 사용하는 객체들의 역할과 구분

Command / Query
- 유스케이스의 입력을 표현하는 객체
- Command: 상태를 변경하는 요청 (예: CreateOrderCommand)
- Query: 상태를 조회하는 요청 (예: GetOrderQuery)
- 유스케이스의 의도를 명확히 드러냄
- 자기 유효성 검증(Self-Validation)을 포함할 수 있음

DTO (Data Transfer Object)
- 계층 간 데이터를 전달하기 위한 객체
- 비즈니스 로직을 포함하지 않음
- 외부 API의 요청/응답 형식에 맞게 구성
- 도메인 모델이 외부에 직접 노출되는 것을 방지

도메인 모델
- 핵심 비즈니스 로직과 규칙을 포함하는 객체
- 계층 경계를 넘어 외부로 노출되어서는 안 됨 (매핑 전략에 따라 다름)
- 영속성 계층의 엔티티와 분리하는 것이 이상적

주의점
- 도메인 모델을 Controller의 응답으로 직접 반환하면, API 스펙 변경이 도메인에 영향을 줌
- 영속성 엔티티를 서비스 계층에서 직접 사용하면, 테이블 구조 변경이 비즈니스 로직에 영향을 줌
- 각 계층의 모델을 분리하면 변경의 영향 범위를 해당 계층 내로 제한할 수 있음
<br><br>

- [참고글](https://techblog.woowahan.com/2561/)
