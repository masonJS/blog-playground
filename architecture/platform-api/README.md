# 플랫폼 API 설계

## 1. 플랫폼 API란 무엇인가

플랫폼 API는 특정 화면이나 클라이언트에 종속되지 않고, **비즈니스 도메인의 리소스(Resource)** 를 중심으로 설계하는 API 방식이다.

예를 들어, 하나의 이커머스 서비스에서 상품, 리뷰, 셀러, 배너라는 도메인이 있다면 각각을 독립적인 API로 표현한다.

```
GET /products/{id}          — 상품 리소스
GET /products/{id}/reviews  — 상품의 리뷰 리소스
GET /sellers/{id}           — 셀러 리소스
GET /banners?placement=home — 배너 리소스
```

각 API가 하나의 도메인 개념을 표현하고, 클라이언트는 필요한 리소스들을 조합해서 화면을 구성한다. API 자체가 **비즈니스 도메인의 계약(Contract)** 역할을 하며, 어떤 클라이언트든 동일한 인터페이스를 통해 데이터에 접근할 수 있다.

---

## 2. 화면 맞춤형 API란 무엇인가

화면 맞춤형 API(Screen-driven API)는 클라이언트의 특정 화면이나 기능에 1:1로 대응하는 API 방식이다. BFF(Backend For Frontend) 패턴의 극단적인 형태로 볼 수도 있다.

```
GET /home              — 홈 화면에 필요한 모든 데이터
GET /product-detail/1  — 상품 상세 화면 (리뷰 + 관련상품 + 셀러정보 모두 포함)
```

클라이언트 입장에서는 한 번의 호출로 화면에 필요한 데이터를 모두 받을 수 있어 초기 개발이 간편하다. 하지만 프로젝트가 성장하면서 다양한 문제가 누적된다.

---

## 3. 화면 맞춤형 API의 문제점

### 3.1 API 폭발

처음에는 `GET /home` 하나로 깔끔하게 시작하지만, 시간이 지나면서 동일한 도메인 데이터를 내려주는 유사한 API가 계속 늘어난다.

- 모바일 앱이 추가되면 `GET /mobile/home`
- 어드민에서 같은 데이터를 다른 형태로 필요로 하면 `GET /admin/home-contents`
- 이벤트 페이지에서 홈의 배너를 재사용하고 싶지만 홈 API에 묶여 있어 `GET /event/banners`를 별도로 생성

결국 같은 도메인 데이터를 내려주는 비슷한 API가 5~6개씩 생기고, 배너의 응답 스펙이 변경되면 해당 API를 모두 찾아서 수정해야 한다.

### 3.2 백엔드의 프론트엔드 종속

실무에서 가장 고통스러운 부분이다. 화면 맞춤형 API 구조에서는 디자이너가 홈 화면 레이아웃을 변경한 것만으로도 백엔드 API 수정과 배포가 필요하다. "이 필드 순서를 바꿔달라", "여기에 셀러 이름도 추가해달라" 같은 요청이 끊임없이 들어오며, 백엔드 개발자는 API 설계자가 아니라 프론트엔드의 데이터 서빙 담당자가 된다.

플랫폼 API라면 "셀러 정보는 `GET /sellers/{id}`로 이미 제공하고 있으니 그것을 사용하면 된다"로 끝날 대화가, 화면 맞춤형에서는 "상품 상세 API에 셀러 이름 필드를 추가해서 배포해달라"가 된다.

### 3.3 도메인 로직의 분산

예를 들어 "배너 노출 조건"이라는 비즈니스 로직이 있다면, `GET /home` 핸들러 안에 배너 필터링 로직이 들어가고, `GET /event-page` 핸들러에도 유사한 로직이 복사된다. 이후 노출 조건이 변경되면 한쪽만 수정하고 다른 쪽은 놓치는 버그가 발생한다.

플랫폼 API라면 배너 관련 로직이 `GET /banners` 한 곳에 응집되어 있어 이러한 문제를 방지할 수 있다.

### 3.4 테스트와 문서화의 어려움

화면 맞춤형 API는 응답이 비대하고 컨텍스트에 의존적이다. "이 API 응답의 `recommendations` 필드는 로그인 유저일 때만 포함되고, `banner`는 시간대에 따라 달라진다"와 같은 조건부 스펙이 하나의 API에 몰리면 문서화가 어렵고 테스트 케이스가 폭발적으로 증가한다.

### 3.5 성능 최적화의 역설

화면 맞춤형 API가 "한 번에 모든 데이터를 내려주니 성능이 좋다"고 생각하기 쉽지만, 실제로는 그렇지 않은 경우가 많다.

- 화면에서 배너만 갱신하고 싶어도 전체 홈 API를 다시 호출해야 한다.
- 응답이 비대해서 캐싱 전략을 세우기 어렵다. 배너는 1분마다, 추천은 1시간마다 갱신해야 하는데 하나의 API에 묶여 있으면 가장 짧은 주기에 맞출 수밖에 없다.
- 반면 리소스 단위 API는 각각 독립적으로 캐싱할 수 있어서 오히려 더 효율적인 경우가 많다.

---

## 4. 플랫폼 API의 단점

플랫폼 API도 만능은 아니다. 인지해야 할 트레이드오프가 존재한다.

### 4.1 클라이언트의 복잡성 증가

하나의 화면을 구성하기 위해 여러 API를 호출하고 조합해야 하므로, 클라이언트 개발자에게 더 많은 작업 공수와 도메인 컨텍스트가 요구된다.

### 4.2 네트워크 호출 증가

화면 하나를 그리기 위해 여러 번의 API 호출이 필요하면, 네트워크 레이턴시가 누적될 수 있다. 특히 모바일 환경처럼 네트워크 상태가 불안정한 경우 이 영향이 더 크게 느껴진다.

### 4.3 초기 설계 비용

도메인 리소스를 올바르게 정의하고, 리소스 간 관계를 설계하는 데 화면 맞춤형 대비 더 많은 초기 설계 시간이 필요하다. 도메인에 대한 깊은 이해가 선행되어야 한다.

---

## 5. 그럼에도 플랫폼 API가 Core여야 하는 이유

### 5.1 비용 곡선의 차이

화면 맞춤형 API의 비용은 **시간이 지날수록 복리로 증가**한다. 클라이언트가 늘어나고, 화면이 변경되고, 비즈니스 로직이 복잡해질수록 유지보수 비용이 가파르게 올라간다. 반면 플랫폼 API는 초기 설계 비용이 높지만, **한 번 투자하면 그 이후로 계속 회수**되는 구조다.

### 5.2 재사용성과 확장성

웹, 모바일 앱, 어드민, 외부 파트너 등 여러 클라이언트가 같은 API를 조합해서 사용할 수 있다. 새로운 화면이나 기능이 추가되더라도 기존 리소스 API를 조합하면 되므로 백엔드 변경이 최소화된다.

### 5.3 단점은 BFF로 보완 가능

플랫폼 API의 단점인 클라이언트 복잡성과 네트워크 호출 증가는 **BFF(Backend For Frontend) 레이어**를 통해 해결할 수 있다.

```
클라이언트  →  BFF (화면별 조합 담당)  →  플랫폼 API들
```

BFF가 플랫폼 API들을 내부적으로 조합해서 화면에 맞는 응답을 만들어주면, 클라이언트는 여전히 한 번의 호출로 필요한 데이터를 받을 수 있고, 코어 API는 리소스 중심으로 깔끔하게 유지된다. 또는 GraphQL과 같은 기술을 도입하여 클라이언트가 필요한 필드만 선택적으로 가져가도록 할 수도 있다.

### 5.4 판단 기준

프로젝트가 6개월 이상 유지되고 클라이언트가 2개 이상이라면, 플랫폼 API를 코어로 가져가는 것이 거의 항상 이득이다. 단, 프로토타입이나 단기 프로젝트처럼 빠르게 만들고 버리는 경우라면 화면 맞춤형이 합리적인 선택일 수 있다. 중요한 것은 상황에 따른 의도적인 선택이다.
