# 5. IPC 와 pg 의 shared_buffers

## 목차

1. [IPC와 Shared Memory 개념](#1-ipc와-shared-memory-개념)
2. [shared_buffers란?](#2-shared_buffers란)
3. [왜 OS 페이지 캐시와 별도로 존재하는가](#3-왜-os-페이지-캐시와-별도로-존재하는가)
4. [내부 구조](#4-내부-구조)
5. [동기화 메커니즘](#5-동기화-메커니즘)
6. [쿼리 실행 시 데이터 흐름](#6-쿼리-실행-시-데이터-흐름)
7. [시스템 계층 구조](#7-시스템-계층-구조)
8. [설정 및 모니터링](#8-설정-및-모니터링)

---

## 1. IPC와 Shared Memory 개념

### IPC (Inter-Process Communication)

프로세스는 기본적으로 독립된 메모리 공간을 가지고 있어서 서로 직접 데이터를 주고받을 수 없다. 커널이 중재자 역할을 하면서 프로세스들이 데이터를 교환할 수 있도록 여러 방법을 제공하는데, 이를 IPC라고 한다.

### 주요 IPC 메커니즘

| 메커니즘 | 특징 | 사용 예시 |
|---------|------|----------|
| Pipe | 단방향 바이트 스트림 | 쉘에서 `ls \| grep foo` |
| Named Pipe (FIFO) | 파일 시스템에 이름을 가진 파이프 | 관계없는 프로세스 간 통신 |
| Message Queue | 구조화된 메시지 큐 | 메시지 단위 통신 |
| **Shared Memory** | 동일한 물리 메모리 영역 공유 | PostgreSQL shared_buffers |
| Semaphore | 공유 자원 접근 동기화 | Shared Memory와 함께 사용 |
| Socket | 양방향 통신 | 네트워크 및 로컬 프로세스 간 통신 |
| Signal | 비동기 이벤트 알림 | 프로세스 종료 신호 등 |

### Shared Memory

여러 프로세스가 동일한 물리 메모리 영역을 자신의 주소 공간에 매핑해서 직접 읽고 쓰는 방식이다. IPC 중 가장 빠르지만 동기화를 직접 처리해야 한다.

---

## 2. shared_buffers란?

PostgreSQL이 시작할 때 할당하는 공유 메모리 영역이다. 모든 백엔드 프로세스(클라이언트 연결마다 fork되는 프로세스들)가 이 메모리 공간을 함께 사용한다.

### 역할

- 디스크에서 읽어온 테이블과 인덱스의 페이지(기본 8KB 블록)를 캐싱
- 여러 프로세스가 동일한 데이터에 접근할 때 디스크 I/O 없이 메모리에서 바로 읽기 가능
- 통계 정보(`pg_stat_activity` 등) 저장

---

## 3. 왜 OS 페이지 캐시와 별도로 존재하는가

### 도서관 비유

**OS 페이지 캐시** = 건물 로비에 있는 공용 책꽂이
- 누구든 책을 가져다 놓고, 가져갈 수 있음
- 건물 관리인(OS)은 "최근에 누가 만졌나" 정도만 알고, 책 내용이 뭔지는 모름
- 오래 안 만진 책부터 치워버림

**shared_buffers** = 전문 사서가 관리하는 열람실
- 사서(PostgreSQL)는 각 책이 어떤 내용인지, 지금 누가 읽고 있는지, 누가 메모를 적어넣었는지(dirty page) 다 앎
- 훨씬 똑똑한 결정을 내릴 수 있음

### OS 페이지 캐시가 모르는 것들

OS는 파일을 그냥 바이트 덩어리로 본다:

- 이 8KB가 자주 조회되는 인덱스인지, 1년에 한 번 보는 로그 테이블인지
- 지금 어떤 프로세스가 이 페이지를 수정 중인지
- 이 페이지가 아직 WAL에 안 쓰여서 날리면 안 되는지

### PostgreSQL이 아는 것들

PostgreSQL은 페이지의 의미를 안다:

- "이 인덱스 페이지는 거의 모든 쿼리가 건드리니까 절대 내리면 안 돼"
- "이 프로세스가 지금 이 페이지 수정 중이니까 다른 프로세스는 기다려"
- "이 dirty page는 WAL 기록 전까지 디스크에 쓰면 안 돼"

### Buffer Ring 전략

큰 테이블을 full scan하는 배치 쿼리가 돌 때:

- **OS 페이지 캐시만 있다면**: 배치가 읽는 데이터가 캐시에 올라오면서 자주 쓰는 인덱스 페이지들이 밀려남
- **PostgreSQL shared_buffers**: "이건 sequential scan이네, 버퍼 몇 개만 돌려쓰자"라고 판단해서 기존 캐시를 보호

---

## 4. 내부 구조

shared_buffers는 세 가지 요소로 구성된다.

### 4.1 Buffer Descriptors

각 버퍼 슬롯의 메타데이터:
- 어떤 relation의 어떤 블록인지
- dirty 여부
- pin count
- 사용 횟수 (clock sweep용)

### 4.2 Buffer Blocks

실제 8KB 페이지 데이터가 저장되는 공간

### 4.3 Buffer Table (Hash Table)

`(relation ID, block number) → buffer ID` 매핑을 위한 해시 테이블. 특정 페이지가 버퍼에 있는지 빠르게 찾을 수 있게 해줌.

### Clock Sweep 알고리즘

shared_buffers가 가득 찼을 때 어떤 페이지를 내릴지 결정하는 방식:

1. 각 버퍼에 `usage_count`가 있음
2. 페이지에 접근할 때마다 증가 (최대 5)
3. clock hand가 버퍼를 순회하면서:
    - `usage_count > 0`이면 1 감소시키고 넘어감
    - `usage_count == 0`이면 그 버퍼를 victim으로 선택

자주 접근되는 페이지는 usage_count가 계속 보충되니까 evict되지 않음.

---

## 5. 동기화 메커니즘

PostgreSQL은 연결마다 별도 프로세스를 fork한다. 여러 프로세스가 동시에 같은 shared_buffers를 접근하므로 동기화가 필수다.

### 5.1 Buffer Pin

"이 버퍼 쓰고 있어, 치우지 마"라는 표시

```
프로세스 A: "버퍼 42번 pin 할게" → pin_count: 0 → 1
프로세스 B: "버퍼 42번 pin 할게" → pin_count: 1 → 2
```

- pin이 걸려 있으면 해당 버퍼는 절대 evict 안 됨
- Clock sweep이 `pin_count > 0`인 버퍼를 만나면 건너뜀
- 동시 접근을 막는 건 아님 (그건 Lock이 담당)

### 5.2 LWLock (Lightweight Lock)

버퍼 내용에 대한 실제 접근 제어

**Shared 모드 (읽기)**: 여러 프로세스가 동시에 획득 가능

```
프로세스 A: shared lock 획득 (읽기)
프로세스 B: shared lock 획득 (읽기) ← 동시에 가능
프로세스 C: exclusive lock 요청 (쓰기) ← 대기해야 함
```

**Exclusive 모드 (쓰기)**: 혼자만 획득 가능

```
프로세스 A: exclusive lock 획득 (쓰기)
프로세스 B: shared lock 요청 (읽기) ← 대기
프로세스 C: exclusive lock 요청 (쓰기) ← 대기
```

### 5.3 Spinlock

아주 짧은 순간의 보호 (buffer descriptor 업데이트 등)

```c
spinlock_acquire(buffer->lock);
buffer->pin_count++;  // 이 한 줄 실행하는 동안만 보호
spinlock_release(buffer->lock);
```

대기할 때 sleep 안 하고 계속 루프 돌면서 확인 (busy-wait). 아주 짧은 작업에만 사용.

### 동기화 메커니즘 비교

| 메커니즘 | 목적 | 대기 방식 |
|---------|------|----------|
| Pin | 메모리에서 사라지지 않게 | 대기 없음 (카운터만 증가) |
| LWLock | 읽기/쓰기 충돌 방지 | sleep 후 깨어남 |
| Spinlock | 메타데이터 원자적 수정 | busy-wait (짧은 루프) |

---

## 6. 쿼리 실행 시 데이터 흐름

### 시나리오

```sql
SELECT * FROM users WHERE id = 42;
```

### Case 1: shared_buffers에 이미 있는 경우 (Best)

```
Spring 서버
    │
    ▼ (TCP/Unix Socket)
PostgreSQL 백엔드 프로세스
    │
    │ 1. 인덱스 탐색으로 페이지 번호 확인 (예: 페이지 157)
    │ 2. 해시 테이블 조회: (users, 157) → 버퍼 슬롯 찾음
    │ 3. 버퍼에 pin 걸기
    │ 4. shared lock 획득
    │ 5. 버퍼에서 직접 데이터 읽기 ← 메모리 접근만!
    │ 6. lock 해제, unpin
    ▼
결과 반환
```

디스크는 물론이고 OS 페이지 캐시도 안 건드림. 마이크로초 단위.

### Case 2: OS 페이지 캐시에 있는 경우

```
PostgreSQL 백엔드 프로세스
    │
    │ 1. 해시 테이블 조회 → 버퍼에 없음
    │ 2. 빈 버퍼 슬롯 확보
    │ 3. read() 시스템 콜 호출
    │         │
    ▼         ▼
         OS 커널
            │
            │ 페이지 캐시에서 찾음
            │ 페이지 캐시 → 유저 공간 버퍼로 복사
            │
    ▼       │
    │ 4. shared_buffers에 로드
    │ 5. pin + shared lock + 읽기 + 해제
    ▼
결과 반환
```

시스템 콜 오버헤드와 메모리 복사가 있음. 밀리초 이하.

### Case 3: 디스크까지 가는 경우 (Worst)

```
PostgreSQL 백엔드 프로세스
    │
    │ 1. 해시 테이블 조회 → 버퍼에 없음
    │ 2. read() 시스템 콜 호출
    │         │
    ▼         ▼
         OS 커널
            │
            │ 페이지 캐시에도 없음
            │ 디스크 I/O 요청
            │         │
            ▼         ▼
              디스크 (SSD/HDD)
                  │
                  │ 물리적으로 데이터 읽기
                  │ (SSD: ~0.1ms, HDD: ~10ms)
                  │
                  ▼
            OS 페이지 캐시에 로드
                  │
         유저 공간 버퍼로 복사
            │
    ▼       │
    │ 3. shared_buffers에 로드
    │ 4. pin + shared lock + 읽기 + 해제
    ▼
결과 반환
```

### UPDATE 시 흐름

```sql
UPDATE users SET name = 'new_name' WHERE id = 42;
```

1. 페이지를 shared_buffers에 로드 (위 과정과 동일)
2. **exclusive lock** 획득 (쓰기니까 혼자만)
3. 페이지 수정 + **dirty 플래그 ON**
4. WAL 버퍼에 변경 로그 기록
5. lock 해제, unpin
6. 커밋 시 WAL을 디스크에 fsync (내구성 보장)
7. dirty page는 나중에 **checkpoint** 때 디스크로 flush

UPDATE해도 바로 디스크에 안 쓴다. shared_buffers에만 수정하고 dirty 표시. 실제 디스크 쓰기는 checkpoint나 background writer가 나중에 처리.

---

## 7. 시스템 계층 구조

### 전체 아키텍처

```
┌─────────────────────────────────────────┐
│           애플리케이션 계층              │
│  ┌─────────────┐    ┌────────────────┐  │
│  │   Spring    │    │  PostgreSQL    │  │
│  │   서버      │    │  (프로세스)     │  │
│  └─────────────┘    └────────────────┘  │
│         유저 공간 (User Space)           │
└─────────────────────────────────────────┘
                    │
                    │ 시스템 콜 (read, write 등)
                    ▼
┌─────────────────────────────────────────┐
│              OS 커널                     │
│         (Linux, Windows 등)             │
│  ┌─────────────────────────────────┐   │
│  │        페이지 캐시               │   │
│  └─────────────────────────────────┘   │
│         커널 공간 (Kernel Space)         │
└─────────────────────────────────────────┘
                    │
                    │ 디바이스 드라이버
                    ▼
┌─────────────────────────────────────────┐
│              하드웨어                    │
│         (디스크, 메모리, CPU)            │
└─────────────────────────────────────────┘
```

### 캐시 계층

```
        속도 빠름 ◀───────────────────▶ 속도 느림
        용량 작음 ◀───────────────────▶ 용량 큼

┌─────────────────┐
│  CPU 캐시       │  ← 프로세스 내 연산
└────────┬────────┘
         ▼
┌─────────────────┐
│ shared_buffers  │  ← PostgreSQL이 관리, 똑똑한 eviction
│   (수백MB~수GB) │
└────────┬────────┘
         ▼
┌─────────────────┐
│ OS 페이지 캐시   │  ← 커널이 관리, 범용적
│   (남는 RAM)    │
└────────┬────────┘
         ▼
┌─────────────────┐
│    디스크       │  ← 영구 저장소
│  (TB 단위)      │
└─────────────────┘
```

### PostgreSQL과 커널의 관계

PostgreSQL은 커널 위에서 돌아가는 일반 프로그램이다. 직접 디스크를 건드릴 권한이 없고, 항상 커널한테 시스템 콜로 요청해야 한다.

```
PostgreSQL: "커널아, 이 파일 읽어줘" → read() 시스템 콜
커널:       "페이지 캐시 확인... 없으면 디스크에서 읽어서 반환"
PostgreSQL: "고마워, 내 shared_buffers에 복사해둘게"
```

---

## 8. 설정 및 모니터링

### 현재 설정 확인

```sql
SHOW shared_buffers;
```

### 권장 설정

일반적으로 시스템 메모리의 25% 정도를 권장하지만, 워크로드에 따라 다름.

- **너무 작으면**: 캐시 히트율이 낮아져서 디스크 I/O가 많아짐
- **너무 크면**: OS 페이지 캐시와 이중 캐싱 발생, checkpoint 시 I/O 스파이크

### 버퍼 캐시 히트율 확인

```sql
SELECT 
  sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) as hit_ratio
FROM pg_statio_user_tables;
```

- **99% 이상**: 충분함
- **그보다 낮으면**: shared_buffers 증가 또는 쿼리/인덱스 최적화 고려

### 통계 의미

`pg_statio_user_tables` 통계:
- `heap_blks_hit`: shared_buffers에서 찾음 (Case 1)
- `heap_blks_read`: 디스크/OS 캐시에서 읽어옴 (Case 2, 3)

---

## 요약

| 구성요소 | 역할 | 관리 주체 |
|---------|------|----------|
| shared_buffers | DB 전용 버퍼 캐시 | PostgreSQL |
| OS 페이지 캐시 | 범용 파일 캐시 | OS 커널 |
| 디스크 | 영구 저장소 | 하드웨어 |

PostgreSQL이 자체 버퍼(shared_buffers)를 관리하는 이유는 데이터베이스 특화된 똑똑한 캐시 정책을 적용하기 위해서다. OS 페이지 캐시는 파일의 의미를 모르지만, PostgreSQL은 어떤 페이지가 중요한지, 언제 디스크에 써야 하는지 알기 때문에 더 효율적인 결정을 내릴 수 있다.
