## 4장 설계 품질과 트레이드오프

### 서론
```
협력은 애플리케이션의 기능을 구현하기 위해 메시지를 주고받는 객체들 사이의 상호작용이다.
책임은 객체가 다른 객체와 협력하기 위해 수행하는 행동이고,
역햘은 대체 가능한 책임의 집합이다.

객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는
활동이다.
(낮다, 높다의 기준이 무엇일까?)

설계는 변경을 위해 존재하고 변경에는 어떤 식이든 비용이 발생한다.
훌륭한 설계란 합리적인 비용안에서 변경을 수용할 수 있는 구조를 만드는 것이다.
적절한 비용안에서 쉽게 변경할 수 있는 설계는 응집도가 높고 서로 느슨하게 결합돼 있는 요소로 구성된다.

객체를 단순한 데이터의 집합으로 바라보는 시각은 객체의 내부 구현을 퍼블릭 인터페이스에 노출시키는 결과를
낳기 때문에 결과적으로 설계가 변경에 취약해진다.

영화 예매 시스템을 책임이 아닌 상태를 표현하는 데이터 중심의 설계를 살펴보고 객체지향적으로 설계한 구조와
어떤 차이점이 있는지 살펴보겠다.
```

### 01. 데이터 중심의 영화 예매 시스템
```
여기서는 '상태'와 '데이터'를 동일한 의미로 사용하겠다.

객체의 상태는 구현에 속한다.
그에 비해 객체의 책임은 인터페이스에 속한다.

```
#### 데이터를 준비하자


### 02. 설계 트레이드오프

```
객체지향 커뮤니티에서는 오랜 기간 동안 좋은 설계의 특징을 판단할 수 있는 기준에 관한 다양한 논의가 있어 왔다.
여기서는 데이터 중심 설계와 책임 중심 설계의 장단점을 비교하기 위해 캡슐화, 응집도, 결합도를 사용하겠다.
```

#### 캡슐화
```
~ 객체의 내부 구현을 외부로부터 감추기 위해서다.
여기서 구현이란 나중에 변경될 가능성이 높은 어떤 것을 가리킨다.

```

### 응집도와 결합도
```
하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높은 것이고
모듈의 일부만 변경된다면 응집도가 낮은 것이다.

또한 하나의 변경에 대해 하나의 모듈만 변경된다면 응집도가 높지만 다수의 모듈이 함께 변경돼야 한다면
응집도가 낮은 것이다.

다시말해 하나의 모듈을 수정할 때 얼마나 많은 모듈을 함께 수정해야 하는지를 나타낸다.
따라서 결합도가 높으면 높을수록 함께 변경해야 하는 모듈의 수가 늘어나기 때문에 변경하기가 어려워진다.
```

### 03. 데이터 중심의 영화 예매 시스템의 문제점

#### 캡슐화 위반
```
getFee 메서드와 setFee 메서드는 Movie 내부에 fee 라는 이름의 인스턴스 변수가 존재한다는 사실을
퍼블릭 인터페이스에 노골적으로 드러낸다.
```

#### 높은 결합도
```
이때 fee의 타입을 변경한다고 가정해보자.
```

#### 낮은 응집도
```
변경의 이유가 서로 다른 코드들을 하나의 모듈 안에 뭉처놓았기 때문에 변경과 아무 상관이 없는 코드들이
영향을 받게 된다.

하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다. 
새로운 할인 정책을 추가해야한다고 가정해보자.
```

### 04. 자율적인 객체를 향해

#### 캡슐화를 지켜라

#### 스스로 자신의 데이터를 책임지는 객체


### 05. 하지만 여전히 부족하다

#### 캡슐화 위반
```

만약 DiscountCondition 의 속성을 변경해야 한다면 어떻게 될까?
아마도 두 isDiscountable 메서드의 파라미터를 수정하고 해당 메서드를 사용하는 모든 클라이언트도
험깨 수정해야 할 것이다.
내부 구현의 변경이 외부로 퍼져나가는 파급 효과는 캡슐화가 부족하다는 명백한 증거다.

만약 새로운 할인 정책이 추가되거나 제거된다면 어떻게 될것인가?
아마 이 메서드들에 의존하는 모든 클라이언트가 영향을 받을 것이다.
```

#### 높은 결합도

#### 낮은 응집도

### 06. 데이터 중심 설계의 문제점
```
데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다. 
```

