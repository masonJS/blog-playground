# AI 시대, 개발자로 살아남는다는 것

---

## 들어가며: 어느 날 문득 깨달은 불편한 진실

며칠 전, 나는 내가 이해하지 못하는 코드를 프로덕션에 배포했다.

테스트는 통과했다. 코드 리뷰도 받았다. 스테이징 환경에서 문제없이 돌아갔다. 그래서 배포 버튼을 눌렀다. 그런데 문득 이런 생각이 들었다. "이 코드가 정확히 어떻게 동작하는지 내가 설명할 수 있나?" 솔직히 말하면, 없었다.

AI가 제안한 구조를 따랐고, AI가 작성한 로직을 약간 수정했고, AI가 추천한 패턴을 적용했다. 결과물은 깔끔해 보였다. 하지만 누군가 "이 부분 왜 이렇게 했어요?"라고 물으면, 나는 아마 "AI가 이렇게 하는 게 좋다고 해서요"라고 대답했을 것이다.

그 순간 나는 깨달았다. 이건 나만의 문제가 아니다. 지금 이 시대를 살아가는 거의 모든 개발자가 비슷한 경험을 하고 있을 것이다. 그리고 우리는 이 상황이 의미하는 바에 대해 진지하게 생각해봐야 한다.

---

## 1장: 혁명의 한가운데서

### 부정할 수 없는 변화

코파일럿, 커서, 클로드 코드, 코덱스, 제미나이. 지금 우리는 코드를 말로 설명하는 속도로 생성할 수 있는 시대에 살고 있다.

며칠 걸리던 작업이 몇 시간이면 끝난다. 몇 년째 "언젠가 해야지" 하며 미뤄두었던 리팩토링을 드디어 손대고 있다. 새로운 언어나 프레임워크를 배우는 데 걸리는 시간이 극적으로 줄었다. 속도 면에서는 분명 혁명이다.

나 역시 이 도구들의 수혜자다. 예전 같았으면 구글링하고, 스택오버플로우 뒤지고, 문서 읽고, 삽질하는 데 반나절을 썼을 일을 이제는 30분 만에 해결한다. 생산성이 올랐다는 건 체감으로도 명확하다.

### 그런데 왜 불안한가

문제는 속도가 빨라진 만큼 뭔가를 잃어버리고 있다는 느낌이 든다는 것이다.

예전에는 코드 한 줄 한 줄을 직접 타이핑하면서, 그 코드가 왜 필요한지, 어떻게 동작하는지를 자연스럽게 이해하게 됐다. 삽질하는 시간이 곧 학습하는 시간이었다. 에러 메시지와 씨름하면서 시스템의 작동 원리를 체득했다.

지금은 다르다. AI가 코드를 뚝딱 만들어주면, 나는 그걸 훑어보고 "괜찮아 보이네" 하고 넘어간다. 깊이 들여다보지 않는다. 들여다볼 시간에 다음 기능을 만드는 게 더 효율적으로 느껴지기 때문이다.

그렇게 코드가 쌓인다. 내가 완전히 이해하지 못하는 코드가.

---

## 2장: 잘못된 질문을 버리다

### "개발자는 AI에게 대체될 것인가?"

이 질문을 수없이 들었다. 뉴스에서, 컨퍼런스에서, 동료들과의 대화에서. 모두가 이 질문에 대한 답을 찾으려 한다.

그런데 나는 이 질문 자체가 잘못됐다고 생각한다.

이 질문은 '개발자'를 하나의 불가분한 단위로 전제한다. 마치 '개발자'라는 직업이 하나의 덩어리인 것처럼. AI가 이 덩어리를 통째로 대체하거나, 아니면 전혀 대체하지 못하거나. 이분법적인 프레임이다.

하지만 현실에서 '개발자'라는 직함은 그냥 이름일 뿐이다. 내가 하루 동안 하는 일을 나열해보면 이렇다.

- 아침: 슬랙 메시지 확인, 코드 리뷰 2건
- 오전: 신규 기능 설계 회의, 기술 문서 작성
- 점심 후: 버그 수정, 테스트 코드 작성
- 오후: 주니어 개발자 멘토링, 장애 대응 온콜
- 저녁: 레거시 코드 분석, 리팩토링 계획 수립

이 중에서 '코드 작성'은 일부에 불과하다. 그리고 AI가 잘하는 것도, AI가 (아직) 못하는 것도 섞여 있다.

### 더 본질적인 질문

그래서 나는 질문을 바꿨다.

"개발자라는 직업은 어떻게 재정의되고 있는가?"

이렇게 물으면 상황이 훨씬 명확해진다. 개발자가 '대체'되는 게 아니라 '변화'하고 있는 것이다. 마치 자동차가 등장했을 때 마부가 사라진 게 아니라 운전사, 정비사, 교통 설계사 등으로 역할이 분화되고 재정의된 것처럼.

솔직히 말하면, 개발자로서의 나는 이미 대체되어 가고 있다. 정확히 말하면, 내가 머릿속에 그리고 있던 '개발자'의 모습이 빠르게 낡아가고 있다. 코드를 한 줄 한 줄 장인처럼 깎아내는 개발자. 그 이미지는 점점 과거의 것이 되어간다.

---

## 3장: 쉬움의 유혹, 단순함의 가치

### 가장 중요한 구분

최근 몇 년간 내가 배운 것 중 가장 중요한 개념이 있다면, '쉬움'과 '단순함'의 차이다.

**쉬움(Easy)**은 손에 잡히는 것이다. 복사해서 붙여넣으면 바로 돌아가는 것. 패키지 하나 설치하면 해결되는 것. AI한테 물어보면 3초 만에 답이 나오는 것.

**단순함(Simple)**은 얽힌 게 없는 것이다. 각 부분이 하나의 일만 하고, 다른 것과 불필요하게 엮이지 않은 것. 변경했을 때 무슨 일이 일어날지 예측할 수 있는 것.

쉬움은 "빨리 뭔가 추가할 수 있다"는 뜻이고, 단순함은 "내가 만든 걸 이해할 수 있다"는 뜻이다.

이 둘은 완전히 다른 개념이다. 그런데 우리는 너무 자주 이걸 혼동한다.

### 쉬운 길의 대가

사람은 당연히 쉬운 길을 택한다. 나도 그렇다.

구글에서 검색해서 복사? 3초면 된다. npm 패키지 설치? 한 줄이면 끝이다. AI한테 "이거 어떻게 해?"라고 물어보면? 바로 코드가 나온다.

문제는 쉬운 길을 택할 때마다, 지금 당장의 속도와 함께 나중에 올 복잡성을 함께 쌓는다는 것이다.

예전에는 이게 크게 문제가 안 됐다. 복잡성이 천천히 쌓였고, 어느 정도 쌓이면 "이제 정리 좀 해야겠다" 싶을 때 리팩토링할 시간이 있었다. 쌓이는 속도와 정리하는 속도 사이에 균형이 있었다.

AI가 그 균형을 깨버렸다.

### 궁극의 '쉬운 길' 버튼

AI는 궁극의 '쉬운 길' 버튼이다.

너무 쉬우니까 "잠깐, 이게 맞나?" 생각할 틈이 없다. 코드가 바로바로 나오는데 왜 설계를 고민하겠는가. 일단 시켜보고, 안 되면 또 시키고, 또 시키면 된다.

나도 그렇게 했다. 앱에 로그인 기능을 추가할 때였다.

"구글 로그인 추가해줘." 깔끔한 코드가 나왔다.
"카카오도 추가해줘." 또 나왔다.
"애플도." 나왔다.

몇 번 반복하니까 세션이 꼬이기 시작했다. 에러가 터졌다. "이 에러 고쳐줘." 고쳐줬다. 그런데 다른 데서 또 터졌다.

스무 번쯤 대화를 주고받으니까, 이건 더 이상 '개발'이 아니었다. 나도 기억 못 하는 조건들이 얽혀서, 그냥 맥락 관리하느라 정신없는 상황이 됐다. 중간에 버린 코드, 대충 만든 테스트, 여러 가지 다른 접근법의 잔해가 뒤섞여 있었다.

결국 동작은 했다. 테스트도 통과했다. 하지만 누군가 "이 코드 설명해줘"라고 하면? 나는 못 한다.

AI는 "이 설계 별로인데요" 같은 말을 안 한다. 시키는 대로 만들 뿐이다. 그게 문제다.

---

## 4장: 복잡성이라는 괴물

### 본질적 복잡성과 우발적 복잡성

모든 소프트웨어에는 두 종류의 복잡성이 있다.

**본질적 복잡성(Essential Complexity)**은 우리가 풀려는 문제 자체의 어려움이다. 결제 시스템을 만들려면 결제의 복잡성을 다뤄야 한다. 실시간 채팅을 만들려면 동시성의 복잡성을 다뤄야 한다. 이건 피할 수 없다. 소프트웨어가 존재하는 이유 자체에서 오는 복잡성이다.

**우발적 복잡성(Accidental Complexity)**은 문제를 풀기 위해 우리가 덧붙인 것들이다. 임시 우회로. 예전에는 말이 됐던 구조들. 급하게 땜질한 코드. 기술 부채라고 부르는 것들.

문제는 실제 코드에서 이 둘이 뒤섞여 있다는 것이다. 뭐가 진짜 필요한 것이고 뭐가 역사적 이유로 남아있는 것인지, 맥락을 알아야만 구분할 수 있다.

### AI는 구분하지 못한다

여기서 AI의 근본적인 한계가 드러난다.

AI는 잘 짠 코드와 5년 전에 급하게 때운 코드를 구분하지 못한다. 둘 다 그냥 '코드'다. 패턴이다. 학습 데이터다.

AI에게 기술 부채는 부채로 보이지 않는다. 그냥 더 많은 코드일 뿐이다. 비즈니스 로직이 어디서 끝나고 인프라 코드가 어디서 시작하는지, AI는 경계를 보지 못한다.

내가 이걸 뼈저리게 느낀 건 레거시 시스템 리팩토링을 시도했을 때였다.

### 리팩토링의 실패

우리 시스템에는 일종의 '중간 다리' 같은 코드가 있었다. 5년 전에 만든 인가 시스템과 새로운 인증 시스템 사이를 연결하는 어댑터 레이어. 전체를 다시 짤 시간이 없어서 임시로 만든 건데, 그게 5년이나 버텨온 거다.

AI가 있으니까 이걸 깔끔하게 정리할 수 있을 거라 생각했다. 간단해 보였다.

아니었다.

그 '중간 다리'는 단순한 어댑터가 아니었다. 전기 배선이 수도관이랑 엮여 있고, 가스관이랑도 연결돼 있고, 인터넷 선까지 묶여있는 상황이었다. 하나 바꾸려면 전부 건드려야 했다. 인증 관련 코드가 수백 개 파일에 흩어져 있었다.

AI한테 리팩토링을 시켜봤다. 처음 몇 개 파일은 잘 처리했다. 그런데 어느 순간부터 꼬이기 시작했다. 기존 로직과 충돌하고, 테스트가 깨지고, 예상 못 한 곳에서 에러가 터졌다.

더 나쁜 경우도 있었다. AI가 기존 코드를 정리하는 대신, 그 위에 새 코드를 덧씌웠다. 정리하려고 시킨 건데 오히려 더 복잡해진 거다.

왜 그랬을까? AI는 모든 기존 코드를 '살려야 하는 것'으로 봤기 때문이다. 뭘 버려도 되고 뭘 유지해야 하는지, 그 판단을 못 한다.

### 인간만이 할 수 있는 것

하지만 나는 구분할 수 있다. 생각할 시간만 있다면.

뭐가 진짜 필요한 건지 안다. 뭐가 옛날에 누가 급하게 만든 건지 안다. 왜냐하면 맥락을 알기 때문이다. 이 코드가 왜 이렇게 됐는지, 그때 무슨 일이 있었는지, 어떤 제약 조건이 있었는지.

AI는 그 맥락이 없다.

---

## 5장: 지식 격차라는 시한폭탄

### 생성 속도 vs 이해 속도

AI 코딩 도구의 진짜 위험은 여기에 있다.

AI는 몇 초 만에 수천 줄의 코드를 만들어낸다. 그걸 이해하려면 몇 시간이 걸린다. 복잡하면 며칠, 심하면 영영 이해 못 할 수도 있다.

코드 생성 속도와 인간의 이해 속도 사이에 점점 더 큰 간극이 벌어지고 있다. 나는 이걸 '지식 격차'라고 부른다.

이 격차가 위험한 이유는, 시스템이 실패했을 때 드러난다.

큰 시스템은 예상 못 한 방식으로 터진다. 새벽 3시에 알람이 울리고, 급하게 노트북을 열고, 에러 로그를 보고, 코드를 뜯어봐야 한다. 그런데 그 코드를 이해하지 못하면? 손을 댈 수가 없다.

테스트를 통과한 코드와 프로덕션에서 버티는 코드는 다르다. 오늘 작동하는 시스템과 6개월 후에 유지보수할 수 있는 시스템은 다르다. "돌아간다"는 건 충분조건이 아니다.

### 감각의 무딤

더 무서운 건 이거다.

AI의 생성 속도를 따라가려고 생각을 건너뛸 때마다, 이해 못 하는 코드가 쌓이는 것만 문제가 아니다. 문제 상황을 알아채는 능력 자체가 무뎌진다.

개발하다 보면 "이거 점점 복잡해지는데?" 하는 감이 온다. "여기 뭔가 냄새나는데" 하는 직관이 작동한다. 그런데 내 시스템을 이해하지 못하면, 그 감각이 생기지 않는다.

내가 위험한 구조를 알아보는 건, 새벽 3시에 그거 때문에 장애 대응을 해본 적이 있기 때문이다. 내가 단순한 방식을 고집하는 건, 복잡하게 만든 코드를 나중에 유지보수해본 적이 있기 때문이다.

이런 감각은 경험에서 온다. AI한테 시키기만 하면 그 경험을 쌓을 기회가 없어진다.

AI는 그런 경험이 없다. 시키면 시키는 대로 만들 뿐이다. "이 방식은 나중에 문제 될 것 같아요"라고 말해주지 않는다.

---

## 6장: 역사는 반복된다, 하지만 규모가 다르다

### 소프트웨어 위기의 역사

우리가 처음 겪는 상황일까? 아니다.

소프트웨어가 발달할 때마다 개발자들이 "이제 너무 복잡해서 못 하겠다"고 느끼는 시점이 있었다.

1960년대 후반, 컴퓨터 과학자들이 모여서 "소프트웨어 위기"를 선언했다. 수요는 폭발하는데 개발자들이 따라가지 못한다고. 다익스트라는 이렇게 말했다. "컴퓨터가 몇 대 없을 때는 프로그래밍이 별일 아니었다. 그런데 컴퓨터가 강력해지니까 프로그래밍도 엄청 어려워졌다."

하드웨어가 천 배 좋아지니까, 사람들이 원하는 소프트웨어도 천 배 복잡해졌다.

그 뒤로 매 시대마다 새로운 도전이 있었다.

- 70년대: C 언어의 등장
- 80년대: PC의 보급
- 90년대: 자바와 인터넷
- 2000년대: 애자일과 웹 2.0
- 2010년대: 클라우드와 모바일

매번 "이제 개발이 너무 복잡해졌다"는 말이 나왔고, 매번 새로운 도구와 방법론이 등장해서 복잡성을 관리할 수 있게 해줬다.

### 이번은 다르다

그런데 이번은 뭔가 다르다.

예전의 변화들은 복잡성을 '관리'하게 해줬다. 높은 수준의 추상화, 더 나은 도구, 더 효율적인 방법론. 복잡한 것을 더 쉽게 다룰 수 있게 해준 거다.

AI는 복잡성을 '생성'한다. 그것도 무한한 속도로.

코파일럿, 커서, 클로드, 코덱스, 제미나이. 이제 코드를 말로 설명하는 속도로 생성할 수 있다. 패턴은 같은데, 규모가 다르다. 이제는 무한대다.

1986년에 프레드 브룩스가 "은탄환은 없다"라는 유명한 논문을 썼다. 소프트웨어 개발의 생산성을 한 번에 10배 올려줄 마법 같은 건 없다고. 왜냐하면 진짜 어려운 건 타이핑이 아니기 때문이다. 문법 맞추고 코드 치는 건 기계적인 일이다. 진짜 어려운 건 "뭘 만들지?", "어떻게 설계하지?" 이런 질문들이다.

AI가 타이핑을 대신해줘도, 이 질문들은 여전히 어렵다. 오히려 더 중요해졌다.

---

## 7장: 해결책을 찾아서

### 컨텍스트 압축

오랜 시행착오 끝에 나는 하나의 방법을 찾았다. 나는 이걸 '컨텍스트 압축'이라고 부른다.

핵심 아이디어는 간단하다. AI한테 코드를 막 던져주지 말고, 핵심만 정제해서 전달하라.

우리 팀의 주요 코드베이스가 백만 줄 정도 된다. 토큰으로 치면 5백만 개. 어떤 AI도 이걸 한 번에 읽고 이해할 수 없다.

처음에는 코드 덩어리를 AI한테 주고 알아서 파악하게 했다. 결과는 엉망이었다. AI는 복잡한 코드에 파묻혀서 헤맸다.

방법을 바꿨다. 전부 다 주는 대신, 핵심만 골라서 줬다. 설계 문서, 아키텍처 다이어그램, 핵심 인터페이스. 이것들을 정리해서 하나의 명세서로 만들었다.

5백만 토큰이 2천 단어짜리 문서가 됐다. 요구사항, 패턴, 제약 조건을 다 담은 문서. 이러니까 훨씬 깔끔한 코드가 나왔다.

### 3단계 워크플로우

나는 이 접근법을 세 단계로 정리했다.

**1단계: 리서치**

관련된 모든 걸 모은다. 아키텍처 다이어그램, 설계 문서, 슬랙에서 나눈 대화, 과거 장애 보고서. AI를 활용해서 코드베이스를 분석하고 뭐가 뭐랑 연결됐는지 파악한다.

이건 한 번에 끝나는 게 아니다. "캐싱은 어떻게 돼?", "에러 나면 어디서 처리해?", "이 서비스가 죽으면 뭐가 영향받아?" 이런 식으로 계속 파고든다. 분석이 틀리면 고치고, 빠진 맥락이 있으면 추가한다.

결과물은 하나의 정리된 리서치 문서다. 그리고 중요한 건, **이 문서를 내가 직접 검증한다**는 것이다. AI가 만든 요약을 그냥 믿지 않는다. 이 단계에서 실수를 잡으면 나중에 큰 사고를 막을 수 있다.

**2단계: 플래닝**

검증된 리서치를 바탕으로 상세한 구현 계획을 짠다. 코드 구조, 데이터 흐름, 에러 처리 방식, 테스트 전략까지 전부 적는다. 신입 개발자한테 줘도 그대로 따라하면 돌아갈 정도로 구체적으로.

이 단계에서 중요한 결정을 많이 내린다. 로직이 맞는지, 구조가 깔끔한지, 불필요하게 엮인 건 없는지. 나는 경험이 있으니까 문제가 터지기 전에 알아볼 수 있다. AI는 그런 경험이 없다.

계획을 문서화하면 좋은 점이 있다. 리뷰가 빨라진다. 코드 수천 줄을 리뷰하는 건 시간이 오래 걸리지만, 계획 문서는 몇 분이면 검토할 수 있다. 뭐가 만들어질지 코드가 나오기 전에 알 수 있다.

**3단계: 구현**

여기까지 오면 단순해진다. 그게 핵심이다.

명확한 명세가 있으니까 AI가 딴 데로 새지 않는다. 50번 왔다 갔다 하면서 "아 그게 아니라" 하는 대신, 세 번의 집중된 작업으로 끝난다.

그리고 중요한 건, 내가 뭘 만들고 있는지 안다는 것이다. AI가 코드를 만들어도, 그 코드가 뭘 하는지 내가 이해하고 있다. 왜냐하면 내가 계획을 세웠기 때문이다.

### 마법은 없다

솔직히 말하면, 이 방법도 은탄환은 아니다.

아까 말한 레거시 리팩토링 프로젝트. 처음에는 이 3단계를 바로 적용하려고 했다. 안 됐다.

먼저 직접 손으로 해봐야 했다. AI 없이 코드를 읽고, 의존성을 파악하고, 실제로 뭔가를 바꿔보면서 뭐가 터지는지 확인했다. 어려운 과정이었지만 결정적인 순간이었다. 그제야 숨겨진 규칙들이 보이기 시작했다. 코드만 읽어서는 절대 알 수 없었던 것들.

그 경험을 리서치 문서에 담았다. "이 부분을 건드리면 저기서 터진다", "이 패턴은 레거시 이유로 남아있는 거니까 무시해도 된다", "이건 절대 바꾸면 안 된다, 이유는 이거다." 이런 맥락들.

그제야 AI가 쓸만한 코드를 내놓기 시작했다.

3단계 방법론이 효과가 있는 건, 내가 먼저 손으로 해봤기 때문이다. 그 경험 없이 방법론만 따라하면 별 효과 없다.

---

## 8장: 개발자의 재정의

### 코드 생산자에서 시스템 설계자로

GitHub CEO가 자신의 다음 직함이 '코드 크리에이티브 디렉터'가 될 거라고 말했다.

처음 들었을 때는 좀 웃겼다. 그런데 생각해보면 정확한 표현이다. 개발자의 정체성이 변하고 있다. 더 이상 코드 생산이 중심이 아니다. 시스템 설계, 에이전트 지휘, 결과 검증이 중심이 되고 있다.

영화 감독이 직접 카메라를 들지 않아도 영화를 만드는 것처럼, 개발자도 직접 모든 코드를 타이핑하지 않아도 소프트웨어를 만들 수 있는 시대가 오고 있다.

하지만 영화 감독이 영상의 원리를 이해해야 좋은 영화를 만들 수 있듯이, 개발자도 코드의 원리를 이해해야 좋은 소프트웨어를 만들 수 있다.

### 성공하는 개발자의 조건

앞으로 성공하는 개발자는 코드를 가장 많이 생성하는 사람이 아닐 것이다.

자신이 뭘 만들고 있는지 이해하는 사람.
본질과 우발을 구분할 수 있는 사람.
경계를 볼 수 있는 사람.
잘못된 문제를 풀고 있다는 걸 알아채는 사람.

이건 AI가 해줄 수 없다. 이건 오직 우리만 할 수 있다.

### 경험의 역설

아이러니한 상황이 있다.

AI가 반복적인 작업을 대신해주면, 그 작업을 통해 쌓았던 경험을 얻을 기회가 줄어든다. 주니어 개발자가 처음부터 AI를 쓰면, 삽질을 통해 배우는 과정을 건너뛰게 된다.

그런데 시니어가 시니어인 이유는 그 삽질을 해봤기 때문이다. 새벽 3시에 장애 대응을 해봤기 때문이다. 자신이 짠 복잡한 코드를 6개월 후에 유지보수하면서 고통받아 봤기 때문이다.

AI 시대에 어떻게 다음 세대의 시니어를 양성할 것인가? 이건 아직 풀리지 않은 질문이다.

한 가지 확실한 건, AI를 '쓰는' 것과 AI에 '의존하는' 것은 다르다는 거다. 도구를 쓰되, 도구 없이도 문제를 이해할 수 있는 능력은 유지해야 한다.

---

## 9장: 앞으로의 길

### AI가 바꾼 것과 바꾸지 못한 것

AI가 코드 짜는 방식은 완전히 바꿨다. 이건 부정할 수 없다.

하지만 소프트웨어가 왜 실패하는지에 대해서는 아무것도 바꾸지 못했다.

요구사항을 잘못 이해해서 실패한다. 설계가 복잡해서 실패한다. 소통이 안 돼서 실패한다. 기술 부채가 쌓여서 실패한다. 이런 문제들은 AI 이전에도 있었고, AI 이후에도 있을 것이다.

AI는 코드를 빠르게 만들어줄 뿐, 이런 근본적인 문제를 해결해주지 않는다. 오히려 코드가 빠르게 쌓이면서 이런 문제들이 더 빨리 드러날 수 있다.

### 해결책은 또 다른 도구가 아니다

더 좋은 AI 모델이 나오면 해결될까? 더 나은 프롬프트를 찾으면 될까? 그렇게 생각하지 않는다.

해결책은 또 다른 도구나 방법론이 아니다. 우리가 원래 알고 있던 걸 기억해내는 것이다.

소프트웨어는 결국 사람이 하는 일이다. 어려운 건 코드 치는 게 아니라, 뭘 만들어야 하는지 아는 것이다. 단순함은 쉬움보다 어렵지만, 훨씬 가치 있다. 이해 없이는 유지보수도, 개선도, 장애 대응도 없다.

이건 AI 이전에도 진실이었고, AI 이후에도 진실이다.

### 매일의 선택

결국 매일매일의 선택이다.

AI가 코드를 제안할 때, "돌아가니까 됐다"로 넘어갈 것인가, 아니면 "이게 왜 이렇게 동작하지?" 하고 들여다볼 것인가.

새 기능을 추가할 때, 가장 빠른 방법을 택할 것인가, 아니면 가장 단순한 방법을 택할 것인가.

복잡성이 쌓이는 걸 느낄 때, "나중에 정리하지" 하고 미룰 것인가, 아니면 지금 멈추고 생각할 것인가.

작은 선택들이 쌓여서 큰 차이를 만든다. AI 시대에도 마찬가지다.

---

## 나가며: 여전히 우리의 일이다

글을 시작할 때 던진 질문으로 돌아가자.

"AI가 코드 대부분을 쓸 때, 우리가 여전히 우리 시스템을 이해하고 있을까?"

이 질문에 대한 답은 우리에게 달려 있다.

AI를 쓸지 말지는 더 이상 선택의 문제가 아니다. 이미 결론이 난 문제다. AI를 쓰지 않으면 경쟁에서 뒤처진다.

진짜 질문은 AI를 '어떻게' 쓸 것이냐다.

나는 AI를 도구로 쓴다. 반복적이고 기계적인 작업을 빠르게 처리하는 도구. 하지만 생각은 내가 한다. 설계는 내가 한다. 이해는 내가 한다. 판단은 내가 한다.

그리고 솔직히, 이게 더 재밌다. AI가 보일러플레이트를 다 쳐주니까, 나는 진짜 재밌는 부분에 집중할 수 있다. 아키텍처 고민, 시스템 설계, 복잡한 문제 해결. 개발자가 되고 싶었던 원래 이유.

성공하는 개발자는 코드를 가장 많이 생성하는 사람이 아닐 것이다.

자신이 뭘 만들고 있는지 이해하고,
경계를 볼 수 있고,
잘못된 문제를 풀고 있다는 걸 알아채는 사람일 것이다.

그건 여전히 우리다.
그건 오직 우리뿐이다.

---

