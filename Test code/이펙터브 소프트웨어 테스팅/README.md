# 기억에 남는 부분 정리

## 2. 테스트 피라미드

> 실용적인 테스트에 관해 이야기할때 가장 먼저 결정해야 하는 사항은 어느 수준으로 코드를 테스트하는가 이다.
> 테스트 수준은 크게 단위 테스트, 통합 테스트, 시스템 테스트로 나뉜다.

여기서 테스트 수준이라는 표현이 기억에 남는다.  
뭔가는 지금까지 이 테스트 피라미드 구조를 "단계" 라는 용어로 표현했다.   


> #### 단위 테스트
> 정의
> - 단위 테스트는 시스템에서 작업 단위를 호출하는 자동화된 코드 조각이다. 
> - 작업 단위는 한 메서드, 클래스 또는 함께 동작하는 여러 클래스일수 있다.
> - 
> 장점
> - 빠르다.
> - 다루기 쉽다
> - 작성하기 쉽다.
> 단점
> - 현실성이 떨어진다.
>   - 단일 클래스로 구성된 소프트웨어 시스템은 거의 없다.
>   - 시스템의 수많은 클래스와 클래스 간 상호작용으로 인해 실제 애플리케이션은 단위 테스트와 다르게 동작한다.
>   - 따라서 단위 테스트는 소프트웨어 시스템의 실제 실행 모습을 완벽하게 재현할 수 없다.

단위 테스트에 대한 정의와 장,단점에 대한 소개가 있었다.    
단위 테스트에 대한 단점이 가장 기억에 남고 와닫는 말이었다.


> #### 통합 테스트
> - 코드와 외부 요소 간의 통합을 테스트해야할때 사용하는 테스트 수준이다.
> - 시스템 전체를 테스트하는 대신 구성요소들의 상호작용에 초점을 맞춘다.
> - 단점
>   - 통합 테스트는 단위 테스트보다 더 느리고 더 어렵다.
>   - 데이터베이스 테스트

통합 테스트에 대해서 다시 한번 정의해본 시간이었다.

> #### 데이터베이스 테스트
> - 스키마를 갱신하고 행을 추가 또는 삭제해서 데이터베이스를 테스트 기대 상태로 만들고
> - 테스트가 끝나면 모든 것을 깨끗한 상태로 되돌려야 한다.

> #### 시스템 테스트
> 시스템 전체 테스트 진행
> 테스트 수준중에 가장 현실적이다.
> - 단점
>   - 느리다
>   - 작성하기 어렵다.
>   - 불안정한 경향이 있다.

시스템 테스트의 특징은 가장 현실적이다라는 말이 와닫는다.    

> 테스트 피라미드의 층이 위로 올라갈수록 더 현실적이고 복잡해진다.
> 단위 -> 통합 -> 시스템 테스트

> #### 정리 
> 단위 테스트 - 모든 비즈니스 규칙을 담당 테스트
> 통합 테스트 - 외부 서비스와의 복잡한 통합 테스트
> 시스템 테스트 - 애플리케이션의 주요하고 위험한 실행 흐름 테스트


## 테스트 더블과 모의 객체

> #### 고립성보다 현실성이 낫다. 가능하면 페이크나 스텁, 모의 객체보다 실제 구현을 선택하도록 하자. 
> 필자는 이 의견에 완전히 동의한다.   
> 현실성은 항상 고립성을 이긴다. 
> 실제 의존성을 가지고 테스트하는 일이 너무 어려워진다면 필자는 그것을 모의한다.
> 
> 테스트 더블에 대한 사용 여부
> - 실제 구현의 수행 시간: 필자는 의존성의 실행 시간을 고려해서 모의를 할지 말지 결정한다. 보통 느린 의존성을 모의한다.
> - 실제 구현을 사용하면 얼마나 비결정적이 되는가: 비결정론적 동작에 대해서는 논의하지 않지만, 그러므로 동작을 나타내는 의존성을 모의하기에 좋은 후보이다.

너무 공갑되는 말이다.    
내가 왜 mockist 가 아닌 classicist 를 선호하는지에 대한 이유가 여기에 있다고 생각한다.  
지나친 모의는 오히려 테스트를 어렵게 만들고 내부 구현에 대한 의존성을 높이는 결과를 가져온다.   
그리고 테스트의 본질적인 목적인 기능 검증이라는 측면에서의 신뢰성을 떨어뜨린다.    

## 테스트 주도 개발 

> #### 항상 TDD를 사용해야 할까?
> 필자의 대답은 실용적으로 '아니요'다.
> 개발할 기능을 내가 얼마나 알아야 할지에 따라 다르다 
> - 필자는 설계나 아키텍처, 특정 요구사항에 대한 구현 방법이 명확하지 않을때 TDD를 사용한다.    
>   이러한 경우에는 조금 천천히 진행하면서 여러 가능성을 실험하는 것을 좋아한다. 
>   잘 알고 있는 문제를 작업하고 있다면 문제 해결 방안을 이미 알고 있으므로 몇몇 단계를 생략한다.  
> - 필자는 복잡한 문제를 다루거나 그 문제에 관한 전문성이 부족할때 TDD를 사용한다.  
>   구현 난이드가 있는 경우에 TDD를 적용하면 한 걸음 뒤로 물러서서 요구사항을 학습하고 작은 테스트부터 작성하게 해준다. 
> - 개발 과정에서 배울만한게 없으면 TDD를 사용하지 않는다.
