## 문서 검색


### 문서 검색이란?

문서 검색은 주로 비구조적 자유 텍스트(문서에 한정되지 않음)에서 작동하는 검색입니다.
웹 페이지를 검색하거나 제품을 찾거나 선별된 콘텐츠를 다룰 때 검색 엔진을 사용합니다.
웹 페이지에서 검색 텍스트 상자에 입력하고 "검색"을 클릭하면, 검색 의도에 맞는 결과를 받을 수 있습니다.

검색 엔진은 데이터베이스 기술에서 발전하여 데이터를 저장하고 해당 데이터에 대한 쿼리를 처리합니다.
기존 데이터베이스와 검색 엔진의 차이를 비교하면 다음과 같습니다.

| 구분 | 관계형/NoSQL 데이터베이스 | 검색 엔진 |
|------|--------------------------|-----------|
| 데이터 구조 | 스키마가 정의된 테이블과 열(구조적 데이터) | 메타데이터 + 비구조적 텍스트를 포함하는 문서 |
| 텍스트 처리 | 값의 정확한 일치 | 언어 규칙을 사용해 텍스트를 토큰(용어) 단위로 분리 |
| 결과 반환 방식 | 조건에 일치하는 **모든** 행을 반환 | 관련성 점수로 정렬하여 **최적의** 결과를 반환 |
| 순위 기능 | 없음 (별도 정렬 필요) | 내장된 관련성 순위(Relevance Ranking) |


### 역색인(Inverted Index)

문서 검색의 핵심 자료구조는 **역색인(Inverted Index)** 입니다.

일반적인 데이터베이스의 순방향 인덱스(Forward Index)는 "문서 → 단어" 매핑입니다. 즉, 각 문서에 어떤 단어가 포함되어 있는지를 저장합니다. 반면 역색인은 이를 뒤집어 "단어 → 문서" 매핑을 만듭니다.

**순방향 인덱스 (Forward Index)**

| 문서 | 포함된 단어 |
|------|------------|
| 문서 1 | 검색, 엔진, 데이터 |
| 문서 2 | 데이터, 분석, 쿼리 |
| 문서 3 | 검색, 쿼리, 관련성 |

**역색인 (Inverted Index)**

| 단어 | 포함된 문서 |
|------|------------|
| 검색 | 문서 1, 문서 3 |
| 엔진 | 문서 1 |
| 데이터 | 문서 1, 문서 2 |
| 분석 | 문서 2 |
| 쿼리 | 문서 2, 문서 3 |
| 관련성 | 문서 3 |

사용자가 "검색 쿼리"라고 검색하면, 역색인에서 "검색"이 포함된 문서(1, 3)와 "쿼리"가 포함된 문서(2, 3)를 빠르게 찾아 교집합/합집합 연산을 수행합니다. 순방향 인덱스는 모든 문서를 순회해야 하지만, 역색인은 단어를 키로 바로 조회할 수 있어 대규모 문서 집합에서도 빠른 검색이 가능합니다.


### 텍스트 분석 파이프라인(Analyzer)

검색 엔진이 역색인을 구축하려면 먼저 텍스트를 분석하여 의미 있는 토큰으로 분리해야 합니다. 이 과정을 담당하는 것이 **Analyzer**이며, 세 단계로 구성됩니다.

```
원본 텍스트 → [Character Filter] → [Tokenizer] → [Token Filter] → 토큰(Term)
```

| 단계 | 역할 | 예시 |
|------|------|------|
| **Character Filter** | 텍스트 전처리 (특수문자 제거, HTML 태그 제거 등) | `<p>Running</p>` → `Running` |
| **Tokenizer** | 텍스트를 개별 토큰으로 분리 | `Running quickly` → [`Running`, `quickly`] |
| **Token Filter** | 토큰 변환 (소문자 변환, 어간 추출, 불용어 제거 등) | [`Running`, `quickly`] → [`run`, `quick`] |

예를 들어, `"The Running foxes quickly jumped!"` 라는 텍스트가 Analyzer를 거치면:
1. Character Filter: 특수문자 제거 → `"The Running foxes quickly jumped"`
2. Tokenizer: 공백/구두점 기준 분리 → [`The`, `Running`, `foxes`, `quickly`, `jumped`]
3. Token Filter: 소문자 변환 + 불용어(the) 제거 + 어간 추출(stemming) → [`run`, `fox`, `quick`, `jump`]

이렇게 추출된 토큰이 역색인에 저장되고, 검색 시에도 동일한 Analyzer를 적용하여 사용자의 쿼리를 토큰으로 변환한 뒤 역색인에서 매칭합니다.


### 문서 검색의 주요 과제는 무엇인가요?

문서 검색의 주요 과제는 **데이터 준비 및 수집**과 **검색 관련성** 두 가지 영역으로 나뉩니다.

문서 검색에서 문서 본문(말뭉치, Corpus)은 사용자 생성 콘텐츠 또는 기타 관리되지 않은 콘텐츠에서 비롯됩니다. 이 콘텐츠에는 일반적으로 오타, 반복, 노이즈 데이터가 포함되어 있습니다. 이 데이터를 검색 엔진에 로드하기 전에 정제하고 일반화해야 합니다. 데이터가 준비되면 수집 API를 호출하여 엔진에 로드하고, 문서가 변경될 때마다 업데이트하는 프로세스가 필요합니다.

문서 검색의 핵심 가치는 사용자의 쿼리와 관련된 문서를 정확히 찾아내는 **검색 관련성(Search Relevance)** 입니다. 검색 엔진은 통계적 점수 모델(BM25)을 통해 일치하는 모든 문서에 점수를 매기고 정렬합니다.


### BM25 점수 모델

BM25는 **TF-IDF** 개념을 기반으로 발전한 점수 알고리즘입니다.

**TF (Term Frequency, 용어 빈도)**
- 검색어가 문서 내에서 **얼마나 자주** 등장하는지를 측정합니다.
- "검색"이라는 단어가 3번 등장하는 문서는, 1번 등장하는 문서보다 해당 검색어에 대해 더 관련성이 높다고 판단합니다.

**IDF (Inverse Document Frequency, 역문서 빈도)**
- 검색어가 전체 문서 집합에서 **얼마나 희귀한지**를 측정합니다.
- "the"처럼 거의 모든 문서에 등장하는 단어는 IDF 값이 낮고(변별력 없음), "OpenSearch"처럼 소수의 문서에만 등장하는 단어는 IDF 값이 높습니다(변별력 높음).

**BM25의 개선점**
- 단순 TF-IDF와 달리, BM25는 **TF 포화(saturation)** 를 적용합니다. 즉, 용어 빈도가 일정 수준을 넘으면 점수 증가가 둔화됩니다. "검색"이 100번 등장한다고 해서 10번 등장한 문서보다 10배 관련성이 높지는 않습니다.
- **문서 길이 정규화**를 수행합니다. 긴 문서는 자연스럽게 용어가 더 많이 등장하므로, 문서 길이를 고려하여 짧은 문서와 공정하게 비교합니다.


### Precision(정밀도)과 Recall(재현율)

검색 품질을 평가하는 핵심 지표는 **Precision**과 **Recall** 입니다.

| 지표 | 정의 | 질문 |
|------|------|------|
| **Precision (정밀도)** | 검색 결과 중 실제로 관련된 문서의 비율 | "반환된 결과가 정말 유용한가?" |
| **Recall (재현율)** | 전체 관련 문서 중 검색 결과에 포함된 비율 | "관련된 문서를 빠뜨리지 않았는가?" |

예를 들어, 관련 문서가 총 10개인 검색에서:
- 결과 5개 반환, 그 중 4개가 관련 → Precision = 4/5 = 80%, Recall = 4/10 = 40%
- 결과 20개 반환, 그 중 9개가 관련 → Precision = 9/20 = 45%, Recall = 9/10 = 90%

Precision과 Recall은 일반적으로 **트레이드오프** 관계입니다. 결과를 더 많이 반환하면 Recall은 높아지지만 Precision은 낮아지고, 결과를 엄격하게 필터링하면 Precision은 높아지지만 Recall이 낮아집니다. 좋은 검색 엔진은 이 두 지표의 균형을 최적화합니다.


### 검색 결과를 개선하려면 어떻게 해야 하나요?

효과적인 문서 및 전자 상거래 검색의 핵심은 관련성입니다. 검색 결과가 사용자의 검색 의도를 충족하는지가 중요합니다. 검색 엔진은 다양한 기술을 사용하여 최상의 결과가 맨 위에 오도록 시도하며, 이를 **관련성 순위(Relevance Ranking)** 라고 합니다.

- **다중 필드 가중치**: 검색은 차등 가중치로 여러 필드에 걸쳐 수행할 수 있습니다. 예를 들어, 영화 데이터베이스를 검색하는 경우 제목, 감독, 배우 필드에 걸쳐 검색하되, 배우 일치보다 제목 일치에 더 높은 가중치를 부여할 수 있습니다.
- **최신성 가중치**: 릴리스 날짜 필드를 인덱스에 추가하고 지수 감쇠 함수(exponential decay)를 점수 함수에 적용하여 최신 결과에 가중치를 부여할 수 있습니다.
- **Facet 필터**: 검색 결과를 다양한 기준(카테고리, 속성 등)으로 분류하는 Facet을 제공하여 사용자가 결과를 단계적으로 좁혀갈 수 있도록 합니다. 많은 문서 검색 시스템이 메타데이터에 대한 Facet을 지원하며, 일반적으로 검색 결과 페이지 왼쪽에 카테고리로 표시됩니다.
- **동의어 사전**: 동의어를 추가하면 사용자가 다양한 표현으로 동일한 결과를 찾을 수 있습니다. 예를 들어, "티"를 검색하든 "t셔츠"를 검색하든 동일한 결과를 반환합니다.


### 문서 검색의 미래는 어떤가요?

검색 엔진은 검색어와의 용어 일치에 최적화되어 있습니다. "8피트 소파"를 검색하면 "8", "피트", "소파"를 각각 매칭하여 결과를 반환합니다. 이것이 **키워드 검색**입니다.

하지만 많은 경우 사용자는 정확한 용어를 모르고 **의미(semantic)** 로 검색하고 싶어 합니다. 이것이 **의미 체계 검색(Semantic Search)** 이며, 검색 및 ML 기술의 최전선에 있습니다. 의미 체계 검색을 사용하면 "불 옆에 앉기 위한 편안한 장소"와 같은 쿼리로 8피트 소파를 찾을 수 있습니다.

의미 체계 검색에는 ML 기술이 필요합니다. 항목 및 쿼리의 벡터 공간을 구축한 다음 벡터 유사성 계산을 사용하여 의미적으로 가까운 항목을 찾습니다. 벡터 검색을 사용하면 문서가 쿼리와 공통된 단어나 동의어를 포함하지 않아도 관련 결과로 반환될 수 있습니다. 예를 들어, "자전거 정비"에 대한 검색이 "변속기 윤활"에 대한 문서와 매칭될 수 있습니다. ML 알고리즘이 "변속기 윤활"이 자전거 유지 관리와 의미적으로 가깝다는 것을 학습했기 때문입니다.

> 벡터 검색과 RAG 기반 검색에 대한 자세한 내용은 시리즈의 다음 문서를 참고하세요.
> - [6. VectorSearch](./6.%20VectorSearch.md)
> - [7. RAG search](./7.%20RAG%20search.md)


### AWS의 검색엔진 서비스
- [Amazon OpenSearch Service](https://aws.amazon.com/ko/opensearch-service/): 개발자가 직접 검색엔진을 만들 때 사용.
- [Amazon Kendra](https://aws.amazon.com/ko/kendra/): 인공지능 기반의 똑똑한 검색엔진.
- [Amazon CloudSearch](https://aws.amazon.com/ko/cloudsearch/): 간단한 검색 기능을 제공.
