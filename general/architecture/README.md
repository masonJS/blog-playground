# 아키텍처

### 계층형 아키텍처의 문제점
- 지름길을 택하기 쉬워진다.
 	- 전통적인 계층형 아키텍처에서 적용되는 규칙은 특정 계층에서의 접근은 같은 계층에 있는 컴포넌트나 바로 아래의 계층에만 접근가능하다. 
 	- 이 말뜻은 만약 상위 계층에 위치한 컴포넌트에 접근해야 한다면 간단하게 컴포넌트를 계층 아래로 내려버리면 된다. 
 	- 아무렇지 않게 생각했던 것들이 관심사 분리의 원칙을 지키지 못하고 변경하기 어려운 아키텍처를 만드는 지름길을 가게 한다.

- 서비스 계층의 너비 확장 (Fat Service & Anemic Domain Model)
	- 계층형 아키텍처는 도메인 서비스의 ‘너비'에 대해 규칙으로써 강제하지 않는다. 
- 시스템의 복잡도가 올라갈수록 서비스에 많은 영속성 계층의 의존성을 가지게 되 넓은 서비스를 이루게 된다.
<br><br>

### 단일 책임 원칙
하나의 컴포넌트는 오로지 한가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.	 
위와 같이 정의되는 내용이 일반적이지만 사실 실제 의도를 내포하고 있지않다.		
오로지 한가지 일만 해야 하고는 가장 직관적인 해석에 불가하며 실제 정의는 다음과 같다.

> 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.

단일 책임 원칙에서 ‘책임'은 한 가지 일이 아닌 변경할 이유라고 해석 되어야 한다.		
변경할 이유가 한 가지라는 것은 우리는 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다.
<br><br>

### 비즈니스 규칙 검증 vs 입력 유효성 검증
비즈니스 규칙 검증
- 검증을 위해 도메인 모델의 현재 상태에 접근해야 한다. 
- 서비스의 비즈니스 규칙의 맥락(semantical)에 대한 유효성 검증 
- service에서 처리

입력 유효성 검증
- 검증을 위해 도메인 모델의 현재 상태에 접근할 필요가 없다. 
- 구문상(syntactical)의 유효성 검증 
- controller 에서 처리
<br><br>

### 계층형 패키징 vs 기능형 패키징
계층형 패키징 
- 어플리케이션의 기능및 특성을 구분짓는 패키지 경계가 없다. 
- 어플리케이션이 어떤 유스케이스를 제공하는지 알수 없다.

기능형 패키징 
- 아키텍처의 가시성을 떨어뜨린다. 
- [Java Practices -> Package by feature, not layer](http://www.javapractices.com/topic/TopicAction.do?Id=205)
<br><br>

### 풍부한 도메인 모델 vs 빈약한 도메인 모델
풍부한 도메인 모델
- 서비스에서는 사용자의 의도만 표현하면서 이 의도의 실제 수행작업은 도메인에서 처리 
- 비즈니스 규칙이 도메인 모델에 위치

빈약한 도메인 모델 (Anemic Domain Model)
- 비즈니스 규칙이 서비스에 위치
- [빈약한 도메인 모델](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=muchine98&logNo=220304821784)
<br><br>

### SDP (안정된 의존성 원칙)
> 의존은 안정적인 쪽으로 향해야 한다.

소프트웨어 설계는 정적일수 없고 끊임없는 변화에 대한 수용이 필연적일수 밖에 없다.		
이러한 변화에 대해서 SDP 원칙은 변경이 어려운(안정적인) 모듈이 변경이 큰(불안정적인) 모듈에게 의존하지  않도록 한다.

안정성에 대한 의미		
- 안정성이란 “변경이 쉽지 않다.”라는 의미로 소프트웨어에서의 안정성은 해당 모듈에 의존하는 모듈들이 많으면 많을수록 안전해진다. (해당 모듈의 변경이 의존하고있는 N개의 모듈에 영향을 주기 때문에)		
- “안정성”이라는 단어의 뜻이 긍정의 느낌을 주지만 소프트웨어상에선 “안정적이다”라는 의미는 변경하기 어렵다, 변경을 하기에 많은 리소스가 필요하다.		 
- 변경이 일어나면 많은 사이드 이펙트를 발생한다에 의미를 내포하고 있다.

안정성의 측정
- 불안정성 = 현재 모듈이 의존하고 있는 내부 모듈의 수(Fan-out) / (현재 모듈에 의존하는 외부 모듈의 수 (Fan-in)  + 현재 모듈이 의존하고 있는 내부 모듈의 수(Fan-out))
- 예를 들어 SampleService 가 4개의 객체에 의존하고 있고 1개의 객체(SampleController)에 의존당하고 있다면 4 / (1 + 4) = 4 / 5 = 0.8 의 불안정성을 가진다.

불안정성의
- 최대값인 1은 변경가능성이 높은 모듈 
- 최소값인 0은 변경가능성이 낮은 모듈
<br><br>

### SAP (안정된 추상화 원칙)
> 모듈은 안정적인 만큼 추상화되어야 한다.		

C,S,R 측면에서의 추상성과 안정성 관계
- Controller => (1, 0) (불안정, 구체적)
- Repository => (0, 1) (안정적, 추상적)
- Service 
  - 인프라 서비스 => (0, 1) (안정적, 추상적)
  - 비즈니스 서비스 => 상황에 맞게

<br><br>

- [참고글](https://techblog.woowahan.com/2561/)
