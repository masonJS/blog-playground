## 단위 테스트 
- 단위 테스트와 코드 설계의 관계
  - 코드를 단위 테스트하기 어렵다면 코드 개선이 반드시 필요하다는 것
  - 강결합에서 저품질이 나타나는데 여기서 강결합은 제품 코드가 서로 분리되지 않아서 따로 테스트하기 어려움을 뜻한다.
  - 테스트하기 어려운 코드는 테스트하기 쉬운 코드로 개선해야 한다.
  - 그렇다면 반드시 단위 테스트할수 있다고 해서 반드시 코드 품질이 좋은 것을 의미하지는 않는다. 

- 단위 테스트의 목표는 소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는 것이다.
  - 지속가능하다는 것이 핵심이다.
  - 단위 테스트에서 가장 어려운 부분은 최소 유지비로 최대 가치를 달성하는 것이다.
    > 사람들은 종종 테스트가 많으면 많을수록 좋다고 생각한다. 하지만 그렇지 않다. 코드는 자산이 아니라 책임이다. 
    > 
    > 코드가 더 많아질수록, 소프트웨어 내의 잠재적인 버그에 노출되는 표면적이 더 넓어지고 프로젝트 유지비가 증가한다. 
    > 
    > 따라서 가능한 한 적은 코드로 문제를 해결하는 것이 좋다.
    > 

- 좋은 단위 테스트의 4대 요소
  * 회귀 방지 
  * 리팩터링 내성 
  * 빠른 피드백 
  * 유지 보수성

- 리펙터링 내성
  - 이는 테스트를 '빨간색'(실패)으로 바꾸지 않고 기본 애플리케이션 코드를 리팩토링할 수 있는지에 대한 척도다.
  - 테스트를 깨지지 않게 하고 리팩터링 내성을 높이는 방법은 SUT의 구현 세부 사항과 테스트 간의 결합도를 낮추는 것뿐이다. 즉, 코드의 내부 작업과 테스트 사이를 가능한 한 멀리 떨어뜨리고 최종 결과를 목표로 하는 것이다.

- 빠른 피드백과 유지 보수성
  - 빠른 피드백은 단위 테스트의 필수 속성이다. 테스트 속도가 빠를수록 테스트 스위트에서 더 많은 테스트를 수행할 수 있고 더 자주 실행할 수 있다.

- 목과 테스트 취약성
  - "이부분은 책 내용을 한번 읽어 보면 좋을듯!"

- 통합 테스트를 하는 이유
  > 통합 테스트는 코드(애플리케이션 코드와 애플리케이션에서 사용하는 라이브러리의 코드를 모두 포함)를 더 많이 거치므로 회귀 방지가 단위 테스트보다 우수하다. 또한 제품 코드와의 결합도가 낮아서 리팩터링 내성도 우수하다.
  >
  > 단위 테스트와 통합 테스트의 비율은 프로젝트의 특성에 따라 다를 수 있지만, 일반적인 경험에 비춰본 규칙은 다음과 같다. 
  > 
  > 단위 테스트로 가능한 한 많이 비즈니스 시나리오의 예외 상황을 확인하고, 통합 테스트는 주요 흐름(happy path)과 단위 테스트가 다루지 못하는 기타 예외 상황(edge case)을 다룬다.

  - 모든 프로세스 외부 의존성은 두 가지 범주로 나뉜다. 
    - 관리 의존성(전체를 제어할 수 있는 프로세스 외부 의존성): 이러한 의존성은 애플리케이션을 통해서만 접근할 수 있으며, 해당 의존성과의 상호 작용은 외부 환경에서 볼 수 없다. 대표적인 예로 데이터베이스가 있다. 
    - 비관리 의존성(전체를 제어할 수 없는 프로세스 외부 의존성): 해당 의존성과의 상호 작용을 외부에서 볼 수 있다. 예를 들어 SMTP 서버와 메시지 버드 등이 있다. 
    - 관리 의존성은 실제 인스턴스를 사용하고, 비관리 의존성은 목으로 대체하라. 
    - 관리 의존성을 목으로 대체하면 통합 테스트의 리팩터링 내성이 저하되기 때문이다. 게다가 이렇게 하면 테스트는 회귀 방지도 떨어진다.


- 데이터 베이스 테스트
  > 인메모리 데이터베이스는 일반 데이터베이스와 기능적으로 일관성이 없기 때문에 사용하지 않는 것이 좋다. 
  > 
  > 이는 또 다시 운영 환경과 테스트 환경이 일치하지 않는 문제이며, 일반 데이터베이스와 인메모리 데이터베이스의 차이로 인해 테스트에서 거짓 양성 또는 (더 나쁜!) 거짓 음성이 발생하기 쉽다.
  > 


참고) [아웃사이더님 [Book] 단위 테스트 - 생산성과 품질을 위한 단위 테스트 원칙과 패턴](https://blog.outsider.ne.kr/1628)


## mockist 방식의 단점

복잡성 및 설정 증가: 
- 모의객체 테스트는 종종 고전주의적 접근 방식에 비해 더 많은 설정 및 구성이 필요합니다. 
- 모의 개체를 만들고 구성하는 작업은 특히 복잡한 종속성 또는 상호 작용의 경우 시간이 많이 걸릴 수 있습니다. 
- 이러한 추가적인 복잡성으로 인해 테스트를 유지하고 이해하기가 더 어려워져 잠재적으로 개발 팀의 전체 생산성에 영향을 미칠 수 있습니다.

깨지기 쉬운 테스트: 
- 모의객체 테스트는 테스트 중인 코드의 구현 세부 사항이나 종속성의 변경에 더 민감할 수 있습니다. 
- 모의객체 테스트는 예상되는 상호 작용을 명시적으로 지정하므로 이러한 상호 작용에 영향을 미치는 코드의 모든 변경 사항은 이에 따라 테스트 사례를 업데이트해야 할 수 있습니다. 
- 이로 인해 테스트가 더 부서지기 쉽고 파손되기 쉬워 유지 관리 노력이 증가할 수 있습니다.

구현 세부 사항에 대한 잠재적인 지나친 강조: 
- 모의객체 테스팅은 시스템 전체의 원하는 동작보다는 구현 세부 사항을 확인하는 데 초점을 맞출 수 있습니다. 
- 메서드 호출과 응답을 명시적으로 지정하면 테스트가 코드의 내부 작업과 밀접하게 결합될 수 있습니다. 
- 동작이 변경되지 않은 경우에도 테스트 사례를 업데이트해야 할 수 있으므로 코드 리팩토링 또는 재설계가 더욱 어려워질 수 있습니다.

제한된 통합 테스팅: 
- 모의객체 접근 방식은 기본적으로 실제 종속성을 대체하기 위해 모의 객체를 사용하여 격리된 구성 요소를 테스트하는 데 중점을 둡니다. 
- 이는 단위 테스트 및 특정 동작 격리에 유용할 수 있지만 구성 요소가 서로 통합되거나 실제 시스템과 상호 작용할 때 발생하는 문제를 포착하거나 드러내지 못할 수 있습니다. 
- Mockist 테스트는 종단 간 시나리오 또는 외부 서비스와의 상호 작용에 대한 범위가 부족하여 테스트 범위를 제한할 수 있습니다.

모의 객체에 대한 과도한 의존: 
- 어떤 경우에는 개발자가 모의 객체에 지나치게 의존하게 되어 테스트 프로세스 전반에 걸쳐 모의 객체를 광범위하게 사용할 수 있습니다. 
- 이로 인해 과도한 수의 모의 개체가 생성되어 테스트가 더 복잡해지고 유지 관리가 어려워지고 잠재적으로 시스템의 실제 동작이 가려질 수 있습니다.

## classicist 방식의 단점

격리 부족: 
- 고전주의적 접근 방식은 종종 모의 개체에 크게 의존하지 않고 보다 통합된 또는 실제 환경에서 코드를 테스트하는 데 중점을 둡니다. 
- 이렇게 하면 시스템 동작에 대한 더 넓은 관점을 제공할 수 있지만 특정 구성 요소를 격리하고 테스트하는 것이 어려울 수도 있습니다. 
- 쉽게 사용할 수 없거나 복잡한 설정이 있는 종속성은 신뢰할 수 있고 격리된 테스트를 만드는 데 어려움을 초래할 수 있습니다.

외부 시스템에 대한 종속성: 
- 고전주의 테스트에서 외부 시스템이나 서비스에 의존하는 코드를 테스트할 때 테스트에 필요한 환경을 설정하는 것이 어려울 수 있습니다. 
- 이는 외부 시스템의 가용성과 안정성에 의존하는 더 느리고 취약한 테스트로 이어질 수 있습니다. 
- 이러한 외부 종속성의 테스트 실패 또는 불일치로 인해 테스트 결과에서 거짓 긍정 또는 부정이 발생할 수도 있습니다.

상호 작용에 대한 제한된 제어: 
- 고전주의적 접근 방식은 일반적으로 입력을 기반으로 코드의 전반적인 동작과 출력을 테스트하는 데 중점을 둡니다. 
- 이는 시스템 기능에 대한 높은 수준의 보기를 제공하지만 내부적으로 발생하는 특정 상호 작용 및 종속성에 대한 가시성이 떨어질 수 있습니다.
- 이로 인해 특정 상호 작용과 관련된 오류 또는 디버그 문제의 원인을 정확히 찾아내기가 더 어려워질 수 있습니다.

테스트 복잡성: 
- 경우에 따라 고전주의적 접근 방식은 특정 시나리오 또는 동작을 테스트하기 위해 더 복잡한 설정 및 데이터 준비가 필요할 수 있습니다. 
- 이로 인해 더 길고 더 복잡한 테스트 사례가 생겨 시간이 지남에 따라 테스트 사례를 이해하고 유지하기가 더 어려워질 수 있습니다. 
- 복잡성이 증가하면 가능한 모든 코드 경로와 에지 케이스를 다루기가 어려워져 잠재적으로 코드의 일부 영역이 테스트되지 않은 상태로 남을 수 있습니다.

피드백 지연: 
- 고전주의 테스트는 종속성 및 외부 시스템을 포함하여 보다 통합된 방식으로 코드를 실행하는 경우가 많기 때문에 격리된 단위 테스트에 비해 테스트 실행이 느릴 수 있습니다. 
- 이 느린 피드백 루프는 특히 반복 개발 중에 또는 빠른 피드백이 중요한 TDD(테스트 기반 개발)를 실행할 때 개발자 생산성에 영향을 미칠 수 있습니다.


