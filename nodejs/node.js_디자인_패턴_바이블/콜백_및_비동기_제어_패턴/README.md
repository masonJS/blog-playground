## 1. Node.js 플랫폼

### 1-1 Node.js 철학

**작은 외부 인터페이스**

- Node.js의 모듈은 명확하게 사용될수 있도록 오욛되지 않도록 작은 사이즈, 범위, 최소한의 기능을 노출시킨다.
- Node.js의 모듈이 정의하는 가장 일반적인 패턴은 단일 진입점을 제공하기 위해 단 하나의 함수나 클래스를 노출시킨다.
- Node.js의 모듈은 확장보다는 사용되기 위해 만들어졌다.
  - 확장의 가능성을 제한해 덜 유연하다고 볼순 있지만 유스케이스를 줄이고, 구현을 단순화, 유지관리를 용이하게 한다는 이점을 가진다.
- Node.js의 모듈은 내부를 외부에 노출시키지 않기 위해서 클래스 보다 함수를 노출시키는것을 선호한다.

### 1-2 Node.js는 어떻게 작동하는가

**논 블로킹 I/O**

- 데이터의 읽기, 쓰기작업의 대기가 없이 즉시 반환하는 방식
- 실제 데이터가 반환될 때까지 루프 내에서 리소스를 적극적으로 polling (= busy-waiting) 
- 서로 다른 리소스를 같은 쓰레드에 처리할 수는 있지만 비효율적인 CPU 낭비를 초래

**이벤트 디멀티플렉싱**

- 디멀티플랙싱이란 신호가 원래의 구성요소로 다시 분할되는 작업을 뜻한다.
- 이벤트 디멀티플렉서의 작동 방식
```
watchedList.add(docketA, FOR_READ); 
watchedList.add(fileB, FOR_READ);

// 동기식으로 관찰되는 리소스들중에 읽을 준비가 된 리소스가 있을때까지 블로킹 처리
// 준비된 리소스가 생기면, 이벤트 디멀티 플렉서는 처리를 위한 새로운 이벤트 세트를 반환
while(events = demultiplexer.watch(watchedList)) { 
  
  // 이벤트 루프
  // 디멀티 플렉서에서 반환된 각 이벤트를 처리
  // 모든 이벤트가 처리되면 디멀티플렉서가 처리가능한 이벤트를 반환하기 전까지 블로킹
  for (event of events) { 
    // 이벤트와 관련된 리소스는 블로킹 하지 않으며 항상 데이터를 반환
    data = event.resource.read();
    if (data === RESOURCE_CLOSED) {
      // 리소스가 닫히고 관찰되는 리스트에서 삭제
      demultiplexer.unwatch(event.resource);
    } else {
      // 실제 데이터를 받으면 처리
      consumeData(data);
    }
  }
}

```

